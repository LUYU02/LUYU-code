# JavaScript

## JavaScript基础

### 数据类型

七种原始值  一旦创建不能修改 typeof 检查数据类型

| 1    | Number                       | nan不是数字                               |
| :--- | :--------------------------- | ----------------------------------------- |
| 2    | String                       | `` 模板字符                               |
| 3    | Boolean                      | ""、0、NaN、null、undefined 假 其余都是真 |
| 4    | Undefined (声明未赋值的变量) | 与数字相加弹出NaN                         |
| 5    | Null                         | 和数字相加相当于0                         |
| 6    | BigInt(大整数)               |                                           |
| 7    | Symbol(符号)                 |                                           |

**类型转换**

- 数字转字符串
  - 变量.toString()
  - String(变量)
  - 隐式转换 +
- 字符串转数字
  - parseInt(string) 转换为整型  (es6 转到**Number**上)
  - parseFloat(string) 转换浮点型  (es6 转到**Number**上)
  - Number() 强制转换函数
  - 隐式转换 - * /
- 布尔值
  - Boolean()

#### Number

**Number.isFinite()** 用来检查一个数值是否为有限的就是 `Infinity` (不是数值flase)

**Number.isNaN() ** 用来检查一个值是否为`NaN`

**Number.isInteger()**   用来判断一个数值是否为整数。

**Number.isInteger()** 用来判断一个数值是否为整数 

### 复杂数据类型

对象{}   			函数  ()=>{}     		数组[]

instanceof  判断是对象还是函数或者是数组

判断
	返回数据类型的字符串表达 typeof
		可以判断 undefined/数值/字符串/布尔值/ function  
		不能判断 null和object  object和array
	判断对象的具体类型 instanceof 运算符
		 语法   arr instanceof Array
		判断 对象 数组 函数
	===
		判断 null undefined

### 运算符

- 算数运算符
  - /+ - * / %取余 

- 指数运算符
  
  - **
  
- 链判断运算符
  
  - ?.
  - 左侧的对象是否为`null`或`undefined`。如果是的，就不再往下运算，而是返回`undefined`。
  
  ```javascript
  // 正确的写法
  const firstName = (message
    && message.body
    && message.body.user
    && message.body.user.firstName) || 'default';
  
  const fooValue = fooInput ? fooInput.value : undefined
  // 简写
  const firstName = message?.body?.user?.firstName || 'default';
  const fooValue = myForm.querySelector('input[name=foo]')?.value
  ```
  
- 自增

  - ++num --num  先加(减)后返回 
  - num++ num--  先返回后加(减)

- 比较运算符

  - == 等于有隐式转换
  - != 
  - === !== 数据类型要一致

- 逻辑运算符

  - && 与 and 找false **第一个为真就返回第二个 **假则第一个
  - || 或 or 找true **第一个为真就返回第一个** 假则第二个
  - ! 非 not  反着来

- Null判断运算符

  - ??  

  - 与逻辑运算符一起使用要加括号

  - 但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

- 逻辑赋值运算符

  - ||= &&= ??=


```javascript
// 老的写法
user.id = user.id || 1;

// 新的写法
user.id ||= 1;
```



- 赋值运算符	

  -    +=    -=      *=     /=    %=          =

### 流程控制

- 分支
  - if(表达式){}
  - 表达式1?表达式2:表达式3 **三元表达式**
  - switch(表达式){}  **一一对应**
- 循环
  - for(let i=0;i<n;i++){}  双重for
  - while(表达式){}
  - do{} while(表达式)   至少循环一次

## 对象

### 对象

```javascript
// 创建new 字面量
const 变量=new Object()
const 变量={}
//调用方法
变量.属性名
变量.["属性名"]
变量.方法名()
for(let k in 变量){} 遍历对象 k==属性名 变量[k]==值
```

#### 方法:

- **Object.defineProperty(obj, prop, descriptor)**  方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

```javascript
// 案例 vue2的数据代理
let number=20
const obj = { name: "xiaojiang", sex: "nan" }
      Object.defineProperty(obj, "age", {
       /* value: 20,
        enumerable: true, //控制属性是否可以枚举
        writable: true, //控制属性是否可以被修改
        configurable: true, //控制属性是否可以被删除      */
          //当有人读取 obj 的age属性时，get函数(getter)就会被调用，且返回值就是age的值
          get() {
          console.log("get", this)
          return number
        },
          //当有人修改 obj 的age属性时，get函数(getter)就会被调用，且会收到修改的值
        set(value) {
          console.log("set", this)
          number = value
        },
      })
```



- **Object.assign(目标对象, 被复制的对象)**
  - 将被复制对象中的属性复制到目标对象里，并将目标对象返回  **浅复制**
- **Object.is(value1,value2)**    方法判断两个值是否为同一个值 nan是本身 +0!==-0
- **Object.keys()**
- **Object.values()**
- **Object.entries()**
  - 返回数组 属性名 属性值 [属性名和属性值]
  - for-of 配套使用

```javascript
let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```

- **Object.fromEntries()**  方法是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。

```javascript
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])  // { foo: "bar", baz: 42 }
```

- **Object.create(对象,属性名)**  判断属性是不是自身的属性
- **Object.setPrototypeOf(obj1,obj2)**  将obj2设置为obj1的原型对象
- **Object.getPrototypeOf(obj)**  获取obj的原型对象

### 数组

数组是一种复合数据类型，可以存储多个不同的值，数组存储的数据叫**元素**

特点：**有序 唯一索引**

**数组冒泡排序 数组选择排序**

```javascript
// 创建 new 和 字面量
let arr=new Array()
arr[i]=元素 //设置
arr[i] //读取
arr.lengtg //长度
arr[arr.lengtg] //最后
let arr=[]
```

#### 遍历

for循环遍历

for(变量 of 可迭代的对象){}   		(数组和字符串)

Arrty.forEach() 



#### 方法

- **from()** 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。
- **of()** 方法用于将一组值，转换为数组。
- **find(回调函数,this指向的对象) ,findIndex()，findLast()，findLastIndex()**   
  - 用于找出第一个符合条件的数组成员 
  - 返回值 返回索引 返回值(倒着找) 返回索引(倒着找)
  - 回调函数:元素 索引 数组本身
- **fill()**  方法使用给定值，填充一个数组。
  - 参数:  填充值 起始位置 结束位置
- **entries()，keys() 和 values()**  和for- of 一起使用

```javascript
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

##### 非破坏性

- **Array.isArray(arr)**  
  - 用来检查一个对象是否是数组
- **at(index)**
  - 可以根据索引获取数组中的指定元素
  - at可以接收负索引作为参数 倒着数
- **concat(数组,数组,...)**
  - 用来连接两个或多个数组
  - 非破坏性方法，不会影响原数组，而是返回一个新的数组
- **indexOf(要查询元素[,起始位置])**  
  - 获取元素第一次出现的索引 找不到则返回-1 
- **lastIndexOf(要查询元素[,起始位置])**  
  -  获取元素第一次出现的索引 找不到则返回-1 (倒着找)
- **join(分隔符)**
  - 将数组中的元素连接一个字符串  默认逗号
- **slice(start, end)**  
  - 截取数组 
  - 截取的起始位置（包括该位置）
  - 截取的结束位置（不包括该位置） 这个参数不写直接截取到末尾
  - 如果将两个参数全都省略，则可以对数组进行  **浅拷贝（浅复制**）

------

**高级**

- **filter((element, index, array) => { /* … */ } )** 
  - 将数组的元素保存到一个新的数组中返回
  - 元素 当前元素索引 被遍历数组
- **map((element, index, array) => { /* … */ } )** 
  -  根据当前数组生成一个新数组
  - 元素 当前元素索引 被遍历数组
- **reduce((previousValue, currentValue, currentIndex, array) => { /* … */ }, initialValue)**
  - 循环一遍前两个值的和  当前的值 索引  ,[起始值]

```javascript
// 案例
const arr1 = [7, 9, 10, 9]
      const z12 = arr1.reduce((a, b, c) => {
          // 输出分别是50 7 0
          			 57 9 1
          		     66 10 2
          			 76 9 3
        console.log(a, b, c) 
        /* 
                a=7
                b=9

                a=16
                b=10
                ...

                a=前面两个值的和
                b是a的后面一个值
            */
        return a + b
      }, 50)
      console.log(z12, arr1)  // 85  [7, 9, 10, 9]
```

##### 破坏性

- **push(element...)**
  - 向数组的**末尾添加**一个或多个元素，并返回新的长度
- **unshift(element...)**
  - 向数组的**开头添加**一个或者多个元素,并返回新的长度
- **Array.pop()** 
  - 删除**最后一个元素** 返回被删除的值 此方法更改数组的长度。
- **shift()** 
  - 删除**开头一个元素** 返回被删除值 此方法更改数组的长度。
- **splice()** 
  - 可以删除 插入 替换 数组的元素       **返回被修改的数组**      此方法会改变原数组。
  - 删除:  Array.splice(1, 3)
  - 替换: Arrty.splice(1, 1, "天蓬元帅")
  - 插入: Arrty.splice(1, 0, "牛魔王")
- **reverse()**  
  - 翻转数组 (不用传入参数)

------

**高级**

- **sort()**
  -  sort用来对数组进行排序（会对改变原数组）
  - 默认安卓UnUnicode编码进行排序 先转为字符串在排序
  - Arrty.sort((a,b)=>{a-b}) 升序 数字
  - Arrty.sort((a,b)=>{a-b}) 降序 数字
- **forEach(element,index,array)** 
  - 元素 元素当前索引 遍历的数组


### 函数

```javascript
// 自定义函数
function 函数名 (形参n) {函数体} arguments 伪数组 arguments[等于实参的顺序]
// 匿名函数
const 变量 =function(){}  调用:变量()
// 箭头函数
const 变量 = ()=>{} 
// 立即执行函数
(function(){})()
(function(){}())
// 参数 
如果实参和形参数量相同，则对应的实参赋值给对应的形参
如果实参多余形参，则多余的实参不会使用
如果形参多余实参，则多余的形参为undefined

// 可变参数案例
 function fn3(a, b, ...args) {
        console.log(args)
      }
      fn3(123, 456, "hello", true, "1111") // "hello", true, "1111"
```

**可变参数也叫 (rest参数) (...变量)**

- 可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回
- 可变参数的作用和arguments基本是一致，但是也具有一些不同点：
  - 可变参数的名字可以自己指定
  - 可变参数就是一个数组，可以直接使用数组的方法
  - 可变参数可以配合其他参数一起使用

### 箭头函数

- **箭头函数没有自身的this**，它的this由外层作用域决定，也无法通过call apply 和 bind修改它的this
- 箭头函数中没有arguments
- 箭头函数不能作为构造函数实例化对象
- 箭头函数能简写 一个参数可以不写() 代码体只有一句话可以省略{}

### 高阶函数

如果一个函数的参数或返回值是函数，则这个函数就称为高阶函数

函数也能作为参数传递

```javascript
// 案列
function filter(arr, cb) {
        const newArr = []
        for (let i = 0; i < arr.length; i++) {
          if (cb(arr[i])) {
            newArr.push(arr[i])
          }
        }
        return newArr
      }
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = filter(arr, (a) => a % 2 === 0)
console.log(result)//2 4 6 8 10
```

#### 闭包

**闭包就是能访问到外部函数作用域中变量的函数**   (需要隐藏一些内容使用闭包)

- 构成闭包的要件：
  - 函数的嵌套
  - 内部函数要引用外部函数中的变量
  - 内部函数要作为返回值返回

```javascript
// 案例
//函数在作用域，在函数创建时就已经确定的（词法作用域）
//                和调用的位置无关
  //          闭包利用的就是词法作用域

function outer() {
        let num = 0 // 位于函数作用域中
        return () => {
          num++
          console.log(num)
        }
      }
      const newFn = outer()
      // console.log(newFn)
      newFn() //1
      newFn() //2
```

- **闭包的生命周期：**
  - 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
  - 在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）
- 注意事项:
  - 闭包需要一定的内存空间,相较于类来说,闭包比较浪费空间（类可以使用原型而闭包不能）
  - 需要执行次数较少时，使用闭包
  - 需要大量创建实例时，使用类

#### 递归

**调用自身函数称为递归函数**   (递归的作用和循环是基本一致) (能用循环就用循环)

- 编写递归函数，一定要包含两个要件：
  - 基线条件 ——  递归的终止条件
  - 递归条件 ——  如何对问题进行拆分

```javascript
// 案例 任意数的阶乘
function jieCheng2(num) {
        // 基线条件
        if (num === 1) {
          return 1
        }
        // 递归条件
        // num! = (num-1)! * num
        return jieCheng2(num - 1) * num
      }
      result = jieCheng2(5)
      /* 
                jieCheng2(5)
                    - return jieCheng2(4) * 5
                     - return jieCheng2(3) * 4
                      - return jieCheng2(2) * 3
                        - return jieCheng2(1) * 2
                         - return 1
            */

      console.log(result)
```





### 作用域 

- **全局作用域**: 内部可以访问外部
  - 全局作用域在网页运行时创建，在网页关闭时消耗
  - 所有直接编写到script标签中的代码都位于全局作用域中
  - 全局作用域中的变量是全局变量，可以在任意位置访问
- **局部作用域**: 外部不能访问内部
  - 块作用域是一种局部作用域
  - 块作用域在代码块执行时创建，代码块执行完毕它就销毁
  - 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问
  - 在局部作用域下没有声明直接赋值的变量是全局作用域
  - **函数作用域**
    - 函数作用域也是一种局部作用域
    - 函数作用域在函数调用时产生，调用结束后销毁
    - 函数每次调用都会产生一个全新的函数作用域
    - 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问
    - **var**虽然没有块作用域，但有函数作用域
- **作用域链**
  - 作用域没有则向上一层寻找直到找到变量 全局没有则报错

- **提升**
  - 变量提升
    - 使用var声明的变量，它会在所有代码执行前被声明所以我们可以在变量声明前就访问变量 不会报错 是一个 undefined
  - 函数的提升
    - 使用函数声明创建的函数，会在其他代码执行前被创建所以我们可以在函数声明前调用函数
  - let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问

### this

- 函数在执行时，JS解析器每次都会传递进一个隐含的参数

- 这个参数就叫做 this

- this会指向一个对象

- this所指向的对象会根据函数调用方式的不同而不同

     - 以函数形式调用，this是window
     - 以方法形式调用，this是调用方法的对象
     - 构造函数中，this是新建的对象
     - 箭头函数没有自己的this，由外层作用域决定
     - 通过call和apply调用的函数，它们的第一个参数就是函数的this

- **调用函数的其他两个方法** 用来改变this的指向

     第一个参数都是把函数的this指向给谁

     - 函数.call()
       - 通过call方法调用函数，函数的实参直接在第一个参数后一个一个的列出来
     - 函数.apply()
       - 通过apply方法调用函数，函数的实参需要通过一个数组传递

     **函数.bind()**  是函数的方法，可以用来创建一个新的函数

     - bind可以为新函数绑定this
     - bind可以为新函数绑定参数

- 通过this可以在方法中引用调用方法的对象

- **箭头函数没有自身的this**，它的this由外层作用域决定，也无法通过call apply 和 bind修改它的this,箭头函数中没有arguments

**"use strict" 开启严格模式**



## 浅拷贝和深拷贝

#### 浅拷贝和深拷贝

- **浅拷贝（shallow copy）**  **浅拷贝把内存地址值也复制了**
  - 通常对对象的拷贝都是浅拷贝
  - 浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层）
  - **如果对象中存储的数据是原始值，那么拷贝的深浅是不重要**
  - 浅拷贝只会对对象本身进行复制，不会复制对象中的属性（或元素）
- **深拷贝（deep copy）** **深拷贝没有复制内存地址值**
  - 深拷贝指不仅复制对象本身，还复制对象中的属性和元素
  - 因为性能问题，通常情况不太使用深拷贝
  - structuredClone(变量)  深拷贝方法

#### 对象的复制

- ...（展开运算符)
  - 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
  - 通过它也可以对数组进行浅复制
- Object.assign(目标对象, 被复制的对象)
  - 将被复制对象中的属性复制到目标对象里，并将目标对象返回  **浅复制**
- JSON也能深复制
  - 先转为json字符串 再转回对象 完成深复制
  - JSON.parse(JSON.stringify(obj))

#### **对象序列化 就是对象和json字符串互相转换**

JSON.stringify(obj)

JSON.parse(str)

## 面向对象

**面向对象是编程世界的核心思想 万物皆对象**   

```javascript
/* 
使用Object创建对象的问题：
	1. 无法区分出不同类型的对象
	2. 不方便批量创建对象

在JS中可以通过类（class）来解决这个问题：
	1. 类是对象模板，可以将对象中的属性和方法直接定义在类中
		定义后，就可以直接通过类来创建对象
	2. 通过同一个类创建的对象，我们称为同类对象
		可以使用instanceof来检查一个对象是否是由某个类创建
		如果某个对象是由某个类所创建，则我们称该对象是这个类的实例
语法：
	class 类名 {} // 类名要使用大驼峰命名
	const 类名 = class {}  
                    
通过类创建对象
	new 类()
*/
//创建
class 变量{ //这种方法 属性中的值是不会变的 
    //类的代码块，默认就是严格模式，
	//类的代码块是用来设置对象的属性的，不是什么代码都能写
    name="小江" //只能通过实例来访问 p1.name
    fn(){}   // p1.fn()
    static test="静态属性" //要类去访问  变量.test
    static test(){} //静态方法   变量.test()
}
const p1=new 变量()

class 变量{
// 在类中可以添加一个特殊的方法 constructor
// 该方法我们称为构造函数（构造方法）
// 构造函数会在我们调用类创建对象时执行
    constructor(形参){
        this.形参=形参
    }
}

```

### 面向对象的特点:**封装、继承和多态**

#### 封装(安全性)

```javascript
不仅要存储属性 还要保护数据安全 不然会被任意修改
确保数据安全
	1.私有化 加#
    2.getter(查看属性) setter(设置属性)
		get 属性名(){
			return this.#属性
		}
		set 属性名(参数){
			this.#属性 = 参数
		}
// 案例
class Person {
        //#address = "花果山" // 实例使用#开头就变成了私有属性，私有属性只能在类内部访问
        #name
        constructor(name) {this.#name = name}
        sayHello() {console.log(this.#name)}
        // getter方法，用来读取属性
        getName() {return this.#name}
        // setter方法，用来设置属性
        setName(name) {this.#name = name}
      }
      const p1 = new Person("1")
      p1.sayHello() // 1 这个方法可以随意访问 不安全
      p1.setName('2')
	  console.log(p1.getName()) // 2
```

#### 多态(灵活性)

- 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
- 要调用某个函数，无需指定的类型，只要对象满足某些条件即可
- 如果一个东西走路像鸭子，叫起来像鸭子，那么它就是鸭子
- 多态为我们提供了灵活性

```javascript
// 案例
 class Person {
        constructor(name) {
          this.name = name
        }
      }

      const dog = new Dog("小江")
      console.log(dog) //{name:"小江"}
      function sayHello(obj) {
      	if (obj instanceof Person) { // false
        	console.log("Hello," + obj.name) // Hello,小江
         }
        console.log(obj instanceof Dog) //true    obj是Dog的实例
      }

      sayHello(dog)
```

#### 继承(扩展性)

- 可以通过 extends 关键来完成继承
- 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解）
- 继承发生时，被继承的类称为 父类（超类），继承的类称为 子类
- 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展
- **OCP 开闭原则**
  - 程序应该对修改关闭，对扩展开放

```javascript
// 案例
class Animal {
        constructor(name) {
          this.name = name
        }
        sayHello() {
          console.log("动物在叫~")
        }
      }

class Cat extends Animal {
        // 重写构造函数
        constructor(name, age) {
          // 重写构造函数时，构造函数的第一行代码必须为super()
          super(name) // 调用父类的构造函数
          this.age = age
        }
        sayHello() {
          // 调用一下父类的sayHello
          super.sayHello() // 在方法中可以使用super来引用父类的方法
          console.log("喵喵喵")
        }
      }
const cat = new Cat("汤姆", 3)
cat.sayHello() //   动物在叫~       喵喵喵
console.log(cat) //  Cat {name: '汤姆', age: 3}
```

### 对象的结构和原型对象

对象中存储属性的区域实际有两个：

- 对象自身
  - 直接通过对象所添加的属性，位于对象自身中
- 原型对象（prototype）
  - 对象中还有一些内容，会存储到其他的对象里（原型对象）这个属性叫做____proto____
  - 原型对象也负责为对象存储属性
    - 当我们访问对象中的属性时，会优先访问对象自身的属性,**对象自身没有才会到原型对象中寻找**
  - 会添加到原型对象中的情况：
    - 在类中通过xxx(){}方式添加的方法，位于原型中
    - 主动向原型中添加的属性或方法

```javascript
访问一个对象的原型对象
	对象.__proto__.
	Object.getPrototypeOf(对象)

原型对象中的数据：
	1. 对象中的数据（属性、方法等）
	2. constructor （对象的构造函数）
    
注意：
	原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同
		p对象的原型链：p对象 --> object --> Object原型 --> null
		obj对象的原型链：object --> Object原型 --> null

原型链：
	读取对象属性时，会优先对象自身属性，
		如果对象中有，则使用，没有则去对象的原型中寻找
		如果原型中有，则使用，没有则去原型的原型中寻找
		直到找到Object对象的原型（Object的原型没有原型（为null））
			如果依然没有找到，则返回undefined
作用域链，是找变量的链，找不到会报错
原型链，是找属性的链，找不到会返回undefined
class Person {
        name = "孙悟空"
        age = 18

        sayHello() {
          console.log("Hello，我是", this.name)
        }
      }

      const p = new Person()

      console.log(p)
	  console.log(p.__proto__.__proto__.__proto__) //null
      console.log(p.constructor) 
      console.log(Object.getPrototypeOf(p) === p.__proto__) // true
```

- **原型的作用：**
  - 原型就相当于是一个公共的区域，可以被所有该类实例访问,可以将该类实例中，所有的公共属性（方法）统一存储到原型中,这样我们只需要创建一个属性，即可被所有实例访问
- JS中继承就是通过原型来实现的,
  - 当继承时，子类的原型就是一个父类的实例

#### 修改原型

```javascript
/* 
                大部分情况下，我们是不需要修改原型对象
                    注意：
                        千万不要通过类的实例去修改原型
                            1. 通过一个对象影响所有同类对象，这么做不合适
                            2. 修改原型先得创建实例，麻烦
                            3. 危险

                处理通过__proto__能访问对象的原型外，
                    还可以通过类的prototype属性，来访问实例的原型
                    修改原型时，最好通过通过类去修改
                    好处：
                        1. 一修改就是修改所有实例的原型
                        2. 无需创建实例即可完成对类的修改

                    原则：
                        1. 原型尽量不要手动改
                        2. 要改也不要通过实例对象去改
                        3. 通过 类.prototype 属性去修改
                        4. 最好不要直接给prototype去赋值

            */
class Person {name = "孙悟空" sayHello() {console.log("Hello，我是", this.name)}}
      Person.prototype.fly = () => {
        console.log("我在飞！")
      }
      const p = new Person()
      const p2 = new Person()
      p.fly()
      p2.fly()
```

#### 其他

- **instanceof** 检查一个对象是否是一个类的实例
  - Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true
  - 语法: console.log(对象instanceof 类)
- **in**: 使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true
  - 语法： console.log("属性名或者方法" in 实例对象)
- **Object.hasOwn(对象, 属性名)**  用来检查一个对象的自身是否含有某个属性



对象的学习：	1.怎么获取对象			2.怎么使用对象的属性和方法 			3.对象代表什么



1. **对象分类：**
   1. 内建对象：Object Function String Number
   2. 宿主对象：由浏览器提供的对象 BOM、DOM
   3. 自定义对象：由开发人员自己创建的对象

## 内置对象

### Map

**Map用来存储键值对结构的数据（key-value）**

- Map和Object的主要区别：
  - Object中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名，JS解释器会自动将其转换为字符串
  - Map中任何类型的值都可以称为数据的key

```javascript
// Map 案例
const map=new Map() //创建
const map2 = new Map([["name", "猪八戒"],["age", 18],[{}, () => {}]]) //创建
const arr = Array.from(map2) // map 转为 数组 二维数组
// 遍历
// for-of
for (const [k, v] of map2) {
        console.log(k, v)//
      }
// forEach
map2.forEach((k,v)=> console.log(k,v))//
```

**属性**

  - map.size 获取map中键值对的数量

**方法**

- **map.set(key, value) **
  - 向map中添加键值对

- **map.get(key)**
  - 根据key获取值

- **map.delete(key) **
  - 删除指定数据

- **map.has(key) **
  - 检查map中是否包含指定键 返回布尔值

- **map.clear()**
  - 删除全部的键值对

- **map.keys()**
  - 获取map的所有的key

- **map.values()**
  - 获取map的所有的value


### Set

**Set用来创建一个集合** 		它的功能和数组类似，不同点在于**Set中不能存储重复的数据**

```javascript
// Set 案例
const set=new Set()
const set=new Set([])
// 属性
set.size 获取数量
// 方法
add() 添加元素
has() 检查元素
delete() 删除元素
clear() 清空
// 遍历
// for-of
      for (const item of set) console.log(item) ;
// forEach
set.forEach((i) => console.log(i) )
```

### Math

Math一个工具类 可以直接使用

Math中为我们提供了数学运算相关的一些常量和方法

- 常量
  - Math.PI 圆周率
- 方法：
  - **Math.abs(x)** 求一个数的绝对值
  - **Math.min(value...)** 求多个值中的最小值
  - **Math.max(value...)** 求多个值中的最大值
  - **Math.pow(x,几次幂)** 求x的y次幂
  - **Math.sqrt(x)** 求一个数的平方根
  - **Math.floor(x)** 向下取整 向小的取
  - **Math.ceil(x)** 向上取整 向大的取
  - **Math.round(x)** 四舍五入取整
  - **Math.trunc(value)** 直接去除小数位 字符串 空值 nan 都会转为NaN
  - **Math.random()** 生成一个0-1之间的随机数
  - **Math.trunc() ** 用于去除一个数的小数部分，返回整数部分。
  - **Math.sign()**   判断一个数到底是正数(1) 负数(-1) 还是零(0)  **返回结果-1 0 1**

### Date

在JS中所有的和时间相关的数据都由Date对象来表示

```javascript
// 案例 
let date=new Date()
date=new Date("2019-12-23T23:34:35")
// new Date(年份, 月, 日, 时, 分, 秒, 毫秒)
date=new Date(2016, 0, 1, 13, 45, 33)
```

方法

- **date.getFullYear()** 获取4位年份
- **date.getMonth()** 返当前日期的月份（0-11） 0表示一月
- **date.getDate()** 返回当前是几日
- **date.getDay()** 返回当前日期是周几（0-6） 0表示周日
- **date.getHours（）** 返回当前在几小时
- **date.getMinutes()** 返回当前在几分钟
- **date.getSeconds()** 返回当前在几秒
- **date.getMilliseconds()** 返回当前在几毫秒
- **date.getTime()** 返回当前日期对象的时间戳
  - 时间戳：自1970年1月1日0时0分0秒到当前时间所经历的毫秒数
  - 计算机底层存储时间时，使用都是时间戳
- **date.now()** 获取当前的时间戳
- **date.toLocaleDateString()** 将本地日期转为字符串 受地区影响
- **date.toLocaleTimeString()**  将本地时间转为字符串 受地区影响
- **date.toLocaleString(locales, options)**
  - 可以将一个日期转换为本地时间格式的字符串
  - 参数:   locales：描述地区    options：选项配置
    - 选项配置:
    - dateStyle 日期的风格
    - timeStyle 时间的风格
    - hour12 是否采用12小时值
    - weekday 星期的显示方式
    - year年    month月    day日
    - dayPeriod 早中晚 ...

### String

字符串其本质就是一个字符数组

属性：length   字符串[索引] 获取指定位置的字符

方法：

- **str.at(index)**           根据索引获取字符，可以接受负索引
- **str.charAt(index)**     根据索引获取字符
- **str.concat(str...)**       用来连接两个或多个字符串
- **str.includes(searchString[, position])**     
  - 用来检查字符串中是否包含某个内容 返回布尔值
  - 两个参数 搜索内容 和 起始位置
- **str.indexOf(searchString, position)**   查询字符串中是否包含某个内容 **第一次出现**
- **str.lastIndexOf(searchString, position)**  查询字符串中是否包含某个内容  **最后一次出**
- **str.startsWith(searchString, position)**                                指定内容开头
- **str.endsWith(searchString, endPosition) **                          指定内容结尾
  - 检查一个字符串是否以指定内容开头(结尾)   返回布尔值
  - 参数: 搜索内容 和 预期要找到的起始(结束)位置
-  **str.padStart(长度,[字符])**           开头
- **str.padEnd(长度,[字符])**               末尾
  - 通过添加指定的内容，使字符串保持某个长度  默认是空格
  - 如果长度<字符串的长度就返回原内容
- **str.repeat(数字)**    方法返回一个新字符串，表示将原字符串重复`n`次。 (不能Infinity和大于-1的数字)
- **str.replace(替换的内容(可以正则表达式),被替换的内容)**   使用一个新字符串替换**一个指定内容**
- **str.replaceAll()**                      使用一个新字符串替换**所有指定内容**
- **str.slice(起始[, 结束])**             对字符串切片，而不修改原始字符串。
- **str.slice()**               截取字符串
- **str.split(分隔符[, 保留几个])**  用来将一个字符串拆分为一个数组  可以跟正则表达式
- **str.toLowerCase()** 转为小写
- **str.toUpperCase()** 转为大写
- **str.trim()**    去除前后空格
- **str.trimStart() **    去掉开始空格
- **str.trimEnd()**       去掉结束空格

## 正则表达式

```javascript
/*正则表达式用来定义一个规则
通过这个规则计算机可以检查一个字符串是否符合规则
	或者将字符串中符合规则的内容提取出来
正则表达式也是JS中的一个对象，
	所以要使用正则表达式，需要先创建正则表达式的对象*/

// new RegExp() 可以接收两个参数（字符串） 1.正则表达式 2.匹配模式
let reg = new RegExp("a", "i") // 通过构造函数来创建一个正则表达式的对象
reg=/a/i     // 使用字面量来创建正则表达式：/正则/匹配模

 
// 案例
      let str = "abcaecafcacc"
      let re = /a(([a-z])c)([a-z])/gi
      let result = re.exec(str) 
      console.log(result)
      while (result) {
        console.log(result[0], result[1], result[2])
        result = re.exec(str)
      }
```

### **修饰符**

i 忽略大小写

g 表示全局匹配

u 表示含义为“Unicode 模式”，用来正确处理大于`\uFFFF`的 Unicode 字符

y 表示从上一次匹配结果剩余的字符串中的第一个开始匹配 全局匹配 (实际上，y修饰符号隐含了头部匹配的标志^)

s 使得`.`可以匹配任意单个字符

d 这个修饰符可以让`exec()`、`match()`的返回结果添加`indices`属性，在该属性上面可以拿到匹配的开始位置和结束位置。

### **边界符**

- ^ 表示^后面第一个字符开头
- $ 表示&最后一个字符结尾

### **字符类**

- [] 表示字符集
  - [a-z] 任意小写字母
  - ...
- [^] 表示取反
- | 表示或
- \- 表示 0-9
- . 表示除了换行外的任意字符 (对于码点大于`0xFFFF`的 Unicode 字符,必须加u)
- \ 表示转义字符
- 其他的字符集
  - \w 任意的单词字符 [A-Za-z0-9_]_
  - _\W 除了单词字符 [^A-Za-z0-9_]
  - \d 任意数字 [0-9]
  - \D 除了数字 [^0-9]
  - \s 空格
  - \S 除了空格
  - \b 单词边界
  - \B 除了单词边界

### **量词**

- {m} 正好m个
- {m,} 至少m个
- {m,n} m-n个
- \+ 一个以上，相当于{1,}
- \* 任意数量的a
- ? 0-1次 {0,1}



### 字符串的正则方法

```javascript
split()
	可以根据正则表达式来对一个字符串进行拆分
search()
	可以去搜索符合正则表达式的内容第一次在字符串中出现的位置
replace()
	根据正则表达式替换字符串中的指定内容
match()
	根据正则表达式去匹配字符串中符合要求的内容
matchAll()
	根据正则表达式去匹配字符串中符合要求的内容(必须设置g 全局匹配)
	它返回的是一个迭代器
```

### 正则实例对象

正则表达式.test(str) // 返回布尔值

正则表达式.exec() //获取字符串中符合正则表达式的内容

正则表达式.unicode //返回布尔值 表示是否设置u修饰符

正则表达式.lastIndex=n //指定从n位置开始匹配

正则表达式.sticky //返回布尔值 表示是否设置y修饰符

正则表达式.source //返回正则的正文

正则表达式.flags //返回正则的修饰符

正则表达式.dotAll //返回正则的是不是处于dotAll模式

## DOM

### 获取元素(查)

- document对象的原型链
  - HTMLDocument -> Document -> Node -> EventTarget -> Object.prototype -> null
- document.documentElement --> html根元素
- document.head --> head元素
- document.title --> title元素
- document.body --> body元素
- document.links --> 获取页面中所有的超链接
- document.getElementById()  跟**id**

- document.getElementsByClassName() 跟**class** 返回是数组 实时刷新
- document.getElementsByTagName() 跟**标签名** 返回是数组 实时刷新
- document.getElementsByName() 跟**name** 返回是数组 实时刷新
- document.querySelector() 跟**选择器**
- document.querySelectorAll() 跟**选择器** 返回是数组 不会实时刷新

### 创建元素节点 (增)

- document.createElement() 跟标签名

### 添加元素节点

- node.appendChild(child)  后面添加
- node.insertBefore(child, 指定元素) 后面添加
- element.insertAdjacentElement("参数",元素)  任意位置 元素前后 元素里面前后

### 获取节点

- element.childNodes 获取当前元素的子节点（会包含空白的子节点）
- element.children 获取当前元素的子元素
- element.firstElementChild 获取当前元素的第一个子元素
- element.lastElementChild 获取当前元素的最后一个子元素
- element.nextElementSibling 获取当前元素的下一个兄弟元素
- element.previousElementSibling 获取当前元素的前一个兄弟元素
- element.parentNode 获取当前元素的父节点
- element.tagName 获取当前元素的标签名

### 删除元素节点

- node.removeChild(child)
- node.remove() 删除当前元素

### 复制节点

- node.cloneNode()  false(浅拷贝)   true(深拷贝)

### 修改文本节点

- element.textContent 获取或修改元素中的文本内容  
  - 不会考虑css样式
- element.innerText 获取或修改元素中的文本内容
  - 会考虑css样式
  - 对标签进行转义
- element.innerHTML 获取或修改元素中的html代码
  - 有xss注入风险

### 属性节点

- 读取:
  - 元素.属性名
  - 元素["属性名"]
  - 元素.getAttribute("属性名")
- 修改:
  - 元素.属性名=值
  - 元素["属性名"]=值
  - 元素.setAttribute(属性名, 属性值)     自定义:data-开头 标准
- 删除：
  - 元素.removeAttribute(属性名)

- 新增: element.dataset.属性名或者 element.dataset[‘属性名’] ie 11才开始支持

### class属性

- classList.add(属性值...) 向元素添加一个或者多个class
- classList.remove() 移除一个或者多个
- classList.toggle() 切换一个class
- classList.replace(被替换,替换)替换
- classList.contains() 检查有没有 返回布尔值



### 事件

鼠标事件 键盘事件 触屏事件

```javascript
// 案例
btn.onclick=function(){
    alert("我又被点了一下~~")
}
// 区别 第二种可以绑定多个事件
btn.addEventListener("click", function () {
        alert("哈哈哈")
      },布尔值) // 第三个参数  true 捕获阶段  false(默认) 冒泡阶段
//   删除事件
//删除对象.事件类型=null
//删除对象.removeEventListener(事件类型,函数名)
```

文档加载 自上而下加载的

- window.onload 事件会在窗口中的内容加载完毕之后才触发
- document的DOMContentLoaded事件会在当前文档加载完毕之后触发

**事件对象**

事件对象是有浏览器在事件触发时所创建的对象，这个对象中封装了事件相关的各种信息

- event.target 触发事件的对象
- event.currentTarget 绑定事件的对象（同this）
- event.stopPropagation() 停止事件的传导 阻止冒泡
- event.preventDefault() 取消默认行为
- e.type 返回类型
- 鼠标事件对象
  - e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标
  - e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标
  - e.pageX 返回鼠标相对于文档页面的X坐标1E9+支持
  - e.pageY 返回鼠标相对于文档页面的Y坐标IE9+支持
  - e.screenX 返回鼠标相对于电脑屏幕的X坐标
  - e.screenY 返回鼠标相对于电脑屏幕的Y坐标
- 键盘事件对象
  - e.key 返回按下的键

**事件委派**

冒泡是 由内向外传导       捕获是 由外向内传导

- 事件传播机制:
- 在DOM中，事件的传播可以分为三个阶段：
  - 捕获阶段 （由祖先元素向目标元素进行事件的捕获）（默认情况下，事件不会在捕获阶段触发）
  - 目标阶段 （触发事件的对象）
  - 冒泡阶段 （由目标元素向祖先元素进行事件的冒泡）

### 获取样式

- getComputedStyle(element) 获取当前元素生效的css样式
  - 参数:1.要获取样式的对象   2.要获取的伪元素
- 元素.clientHeight
- 元素.clientWidth
  - 获取元素内部的宽度和高度（包括内容区和内边距）
- 元素.offsetHeight
- 元素.offsetWidth
  - 获取元素的可见框的大小（包括内容区、内边距和边框）
- 元素.scrollHeight
- 元素.scrollWidth
  - 获取元素**滚动区域的大小**
- 元素.offsetParent
  - 获取元素的**定位父元素**
  - 定位父元素：离当前元素最近的开启了定位的祖先元素，如果所有的元素都没有开启定位则返回body
- 元素.offsetTop
- 元素.offsetLeft
  - 获取元素**相对于其定位父元素**的偏移量
- 元素.scrollTop
- 元素.scrollLeft
  - 获取或设置**元素滚动条**的偏移量

## BOM

BOM浏览器对象模型  BOM为我们提供了一组对象，通过这组对象可以完成对浏览器的各种操作

### BOM对象：

- Window —— 代表浏览器窗口（全局对象）

#### Navigator — 浏览器的对象（可以用来识别浏览器）

- 属性：userAgent 返回一个用来描述浏览器信息的字符串

#### Location —— 浏览器的地址栏信息

- 可以直接将location的值修改为一个新的地址，这样会使得网页发生跳转
- location.assign() 跳转到一个新的地址
- location.replace() 跳转到一个新的地址（无法通过回退按钮回退）
- location.reload() 刷新页面，可以传递一个true来强制清缓存刷新
- location.href 获取当前地址

#### History —— 浏览器的历史记录（控制浏览器前进后退）

- history.back()                  回退按钮
- history.forward()            前进按钮
- history.go()                      可以向前跳转也可以向后跳转

#### Screen —— 屏幕的信息

### 定时器

setTimeout(()=>{},毫秒)  只会调用一次

clearTimeout(定时器名字) 关闭定时器

setInterval(()=>{}.毫秒)  一直调用

clearInterval() 关闭定时器

# ES6-...

## 解构赋值

### **数组的解构赋值 是 一一对应的** 

```javascript
// 案例  数组的
let [a,b,c,...d] = ["A", "B", "C",1,2,3,4,5] // 声明同时解构
console.log(a,b,c,d) // A B C [1,2,3,4,5]
;[a,b,c=10] = [1, 2]
console.log(a,b,c) // 1 2 10
// 可以通过解构赋值来快速交换两个变量的值
      let a1 = 10
      let a2 = 20
;[a1, a2] = [a2, a1] 
console.log(a1,a2)// 20 10
// 二维数组
let [a,b,[c,d]]=[1,2,[3,4]]
console.log(a,b,c,d) // 1 2 3 4
```

### **对象的解构赋值**   

对象的解构赋值必须和对象的属性名一样 不然会返回undefined

对象解构赋值还可以起别名 语法  **属性名：别名   ||  属性名：别名="初始值"**

```javascript
// 案例
const obj = { name: "孙悟空", age: 18, gender: "男" }
// let { name, age, gender } = obj // 声明变量同时解构对象
let name, age, gender //声明变量
;({ name, age, gender } = obj) // 给对象解构赋值需要这样写
let { address } = obj // 没有的属性返回undefined
let { name: a, age: b, gender: c, address: d = "花果山" } = obj
console.log(a, b, c, d)
```

对象序列化 就是对象和json字符串互相转换

JSON.stringify(obj)

JSON.parse(str)

## 扩展运算符 (...变量)

数组合并

```javascript
const arr=[1,2]
const arr1=[3,4]
const arr2=[...arr,...arr1]//1,2,3,4
```

数组克隆 (浅拷贝)

```javascript
const arr=[1,2]
const arr2=[...arr]//1,2 
```

将伪数组转为真数组

```javascript
const divs=document.querySelectorAll("div")
const arr=[...divs] 
```

## 迭代器

遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。 

- ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费 
- 原生具备iterator接口的数据(可用for of遍历
  - Array 
  - Arguments 
  - Set 
  - Map 
  - String 
  - TypedArray 
  - NodeList

**工作原理**

- 创建一个指针对象，指向当前数据结构的起始位置
- 第一次调用对象的next方法，指针自动指向数据结构的第一个成员
- 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员
- 每调用next方法返回一个包含value和 done 属性的对象



注: 需要自定义遍历数据的时候，要想到迭代器。

## 生成器函数

是解决异步编程的新方案 法行为与传统函数完全不同

- \* 的位置没有限制 
- 生成器函数返回的结果是迭代器对象，调用迭代器对象的next方法可以得到 yield语句后的值 
- yield相当于函数的暂停标记(分隔符)，每调用一次next 方法，执行一段代码 
- next方法可以传递实参，作为yield语句的返回值

```javascript
      // 生成器的参数
      function* set(arg) {
        console.log("arg---->" + arg) //调用1
        let one = yield 111
        console.log("one---->" + one) //调用2
        let two = yield 222
        console.log("two---->" + two) //调用3
      }
      let set1 = set("arg") // 不调用 只传参
      console.log(set1)
      console.log(set1.next()) // 调用1   console.log("arg---->" + arg)
      console.log(set1.next("AAA")) // 调用2  console.log("one---->" + one)
      console.log(set1.next("BBB")) // 调用3   console.log("two---->" + two)
```

111



# node

特点:  **单线程  异步  非阻塞  同意apl**

## 安装

 可以用 [nvm](https://nvm.uihtm.com/) 管理 node

- 常见命令
  - nvm version  (查看nvm版本)
  - nvm list (查看node版本)
  - nvm install (安装node 可指定)
  - nvm use (node版本指定)

[无脑安装node(点解链接)](https://nodejs.org/en/ )

npm常见命令

- npm i 包 或者 包@指定版本 (安装)
- npm r 包 (移除)
- npm i  -D 包 (项目上线不会受到影响)





## promise (就是解决异步的回调函数)

- 特点 

  - 解决异步中的回调函数

  - 特殊的存取数据方式 

  - 可以存储异步调用的结果

### 构造函数创建 Promise

```javascript
// 创建Promise时构造函数需要一个函数作为参数 创建回调函数的同时还会有两个参数
const promise = new Promise((resolve, reject) => {
  // resolve 执行正常时存储数据     resolve执行错误时存储数据
  // 通过函数向Promise中添加数据 好处就是可以添加异步调用的数据
  setTimeout(() => {
    // throw new Error("自己写的错误!")
    resolve("正确的小江")
    // reject("错误的小江")
  }, 1000)
  //   resolve("正确的小江")
  //   reject("错误的小江")
})
```

### Promise中维护两个隐藏的属性：

```javascript
/* 
    Promise中维护两个隐藏的属性：
        PromiseResult
            用来储存数据
        PromiseState
            记录Promise的状态
                pending(进行中)
                fulfilled(完成) 通过resolve存储数据时
                rejcted(拒绝,出错) 出错或者通过reject存储数据时
            state只能修改一次,修改后永远不会变
        流程:
            当Promise创建时,PromiseState初始值为pending
                当通过resolve存储数据时 PromiseState 变为fulfilled（完成)
                    PromiseResult变为存储的数据
                 当通过reject存储数据时 PromiseState 变为rejcted（拒绝,出错了)
                    PromiseResult变为存储的数据 或异常对象
                    
            当通过then读取数据,相当于为Promise设置了回调函数
                如果PromiseState变为fulfilled，则调用then的第一个回调函数来返回数据
                如果PromiseState变为rejected，则调用then的第二个回调函数来返回数据
*/
```

### Promise 实例方法

- then需要两个回调函数作为参数 回调函数用来获取promise中的数据 

  - 通过resolve存储的数据，会调用第一个函数返回
    - 在第一个函数中编写处理数据的代码

  - 通过reject存储的数据或者出现异常时，会调用第二个函数返回
    - 在第二个函数中编写异常的代码 

-  catch()用法和then类似，但是只需要一个回调函数作为参数

  - catch()中的回调函数只会在Promise被拒绝时才调用

  - catch()相当于 then(null, reason => {})

  - catch()就是一个专门处理Promise异常的方法

- finally()

  - 无论是正常存储数据还是出现异常了，finally总会执行

  - 但是finally的回调函数中不会接收到数据

  - finally()通常用来编写一些无论成功与否都要执行代码

  **这三个法都会返回一个新的Promise 只有finally()返回值不会存储到Promise中**

### Promise 静态方法

- Promise.resolve() 创建一个立即执行的Promise

- Promise.reject() 创建一个立即执行的Promise

- Promise.all([...]) 同时返回多个Promise的执行结果
  - 其中有一个错误就全错
- Promise.allSettled() 同时返回多个Promise的执行结果
  - 不管错的还是对的 全返回
  - {status: 'fulfilled', value: '错的小江'} 成功的
  - {status: 'rejected', reason: '错的小江'} 错误的
- Promise.race() 返回一个执行最快的Promise (不考虑对错)
- Promise.any() 返回一个执行最快的Promise (全部错误才报错)



## 调用栈 宏任务 微任务

**JS是单线程的，它的运行时基于事件循环机制（event loop）**

- 调用栈
  - 栈是一种数据结构，后进先出
  - 调用栈中，放的是要执行的代码
- 任务队列
  - 队列是一种数据结构，先进先出
  - 任务队列的是将要执行的代码

**当调用栈中的代码执行完毕后，队列中的代码才会按照顺序依次进入到栈中执行(调用栈>任务队列(微>宏))**

- 在JS中任务队列有两种
  - 宏任务队列 （大部分代码都去宏任务队列中去排队）
  - 微任务队列 （Promise的回调函数（then、catch、finally））
- 整个流程
  - 执行调用栈中的代码
  - 执行微任务队列中的所有任务
  - 执行宏任务队列中的所有任务

## async和await

- 通过async可以快速创建异步函数
  - 异步函数的返回值会自动封装到一个Promise中返回
- 在async声明的异步函数中可以使用await关键字来调用函数

```javascript
function sum(a, b) {
    return new Promise((resolve, reject) => {
      setInterval(() => {
        // resolve(a + b)
        reject(a + b)
      })
    })
  }

  async function fn3() {
    // 当我们通过await去调用异步函数时，它会暂停代码的运行
    // 知道异步代码执行有结果时，才会将结果返回
    // 注意 await只能用于 async声明的异步函数中，或es模块的顶级作用域中
    // await只是阻塞内部的代码,外部不会影响
    // 通过await调用异步代码时，需要通过try-catch来处理异常
    try {
      let result = await sum(123, 456)
      console.log(result)
    } catch (e) {
      console.log("出错了!", e)
    }
  }
  fn3()

/*  //1243
 async function fn4() {
    console.log(1)
    await console.log(2)
    console.log(3)
  }
  fn4()

  等价

  function fn5() {
    return new Promise((resolve) => {
      console.log(1)
      console.log(2)
      resolve()
    }).then((r) => console.log(3))
  }
  console.log(4)
*/
```

## 模块化

#### CommonJS规范 (在node中默认)

引入require("文件名或者包名")

- 向外暴露 (指针永远指向module.exports)

  - exports (共享一个)

  - module.exports (共享对象)

#### ES的模块化

要想在node使用ES的模块化，可以采用以下两种方案

1. 使用mjs作为扩展名
2. 修改 package.json 设置为"type":"module" 项目下所有的js文件都默认ES module

```javascript
import sum(默认导出), { a as 别名, c } from "./xxx.mjs"
/*
导入ES模块 不能省略扩展名
通过as指定别名
通过ES模块化,导入的内容都是常量  可以跟对象
默认导出 一个模块只有一个默认导出 export default (跟值)
ES模块都是运行在严格模式下的
*/
```

## 内置模块

默认  global 是node中的全局对象，作用类似于window

ES标准下，全局对象的标准名应该是 globalThis

### process (表示当前的node进程)

**全局变量**

process.exit() (结束当前进程，终止node)

process.nextTick(callback[, …args])  (将函数插入到 tick队列中)

```javascript
调用栈      
tick队列   Commonjs标准下 执行顺序 调用栈 > tick队列 > 微任务队列 > 宏任务队列
微任务队列  ES标准下	   执行顺序 调用栈 > 微任务队列 > tick队列 > 宏任务队列
宏任务队列

/* setTimeout(() => console.log(1)) //宏任务
queueMicrotask(() => {// 变成微任务
  console.log(2) //微任务
})
process.nextTick(() => {
  console.log(3) //tick队列
})
console.log(4) //调用栈 */
```

### path (路径)

需要先引入 require("path")

**方法**

- path.resolve([…paths])  (生成一个绝对路径)

  - dirname (当前文件夹)  filename(当前文件)

- path.join([...paths])  (路径拼接起来)

- path.basename(url,[要删除的后缀])  (获取路径文件名)

- path.extname(url) (获取路径扩展名) 

  

  

### fs (文件系统)

`fs.readFile(path[,options]) `   读取内容

`fs.writeFile(data, options)`  写入内容 文件存在则替换 

`fs.appendFile(data[, options])`  创建新文件，或将数据添加到已有文件中

`fs.mkdir(path[, options])`   创建目录 设置{ recursive: true } 会自动创建不存在的上一级目录

`fs.rmdir(path[, options])`    删除目录

`fs.rm((path[, options])`     删除文件

`fs.rename(oldPath, newPath)` 重命名 (剪切)

`fs.copyFile(src, dest[, mode])` 复制文件 (复制)

### http (创建web服务器)

```javascript
// 1.导入 http 模块
const http = require("http")
// 2.创建 web 服务器实例
const server = http.createServer()
// 3.为服务器实例绑定 request 事件
server.on("request", (req, res) => {
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({
    data: 'Hello World!'
  }));
})
// 启动服务器
server.listen(80, () => {
  console.log("http://127.0.0.1")
})

// 第二种写法
const http = require('node:http');

// 创建本地服务器来从其接收数据
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({
    data: 'Hello World!'
  }));
});

server.listen(80, () => {  
    console.log("http://127.0.0.1")
});
```

**服务器功能** 

1. 接受浏览器的**请求报文**
   1. 请求首行 请求头 空行 请求体
      1. 请求首行: 请求方式 请求资源的路径 协议
      2. 请求头: 名值对结构 用来告诉服务器我们浏览器的信息
      3. 请求体: get没有 post请求通过请求体发送数据
2. 向浏览器返回**响应报文**
   1. 响应首行 响应头 空行 响应体
      1. 响应首行: 协议 状态码 对状态码的描述
      2. 响应头: 名值对结构 用来告诉浏览器响应的信息
      3. 响应体: 服务器返回给客户端的内容

```javascript
    1.当在浏览器中输入地址以后发生了什么？
        https://lilichao.com/hello/index.html
	① DNS解析，获取网站的ip地址
    ② 浏览器需要和服务器建立连接（tcp/ip）（三次握手）
    ③ 向服务器发送请求（http协议）
    ④ 服务器处理请求，并返回响应（http协议）
    ⑤ 浏览器将响应的页面渲染
    ⑥ 断开和服务器的连接（四次挥手）
 
2. 客户端如何和服务器建立（断开）连接
    - 通过三次握手和四次挥手
        - 三次握手（建立连接）
            - 三次握手是客户端和服务器建立连接的过程
                1. 客户端向服务器发送连接请求
                                SYN
                2. 服务器收到连接请求，向客户端返回消息
                                SYN ACK 
                3. 客户端向服务器发送同意连接的信息
                                ACK
 
        - 四次挥手（断开连接）
                1. 客户端向服务器发送请求，通过之服务器数据发送完毕，请求断开来接
                                FIN
                2. 服务器向客户端返回数据，知道了
                                ACK
                3. 服务器向客户端返回数据，收完了，可以断开连接
                                FIN ACK
                4. 客户端向服务器发数据，可以断开了
                                ACK
请求和响应实际上就是一段数据，只是这段数据需要遵循一个特殊的格式，这个特殊的格式由HTTP协议来规定
```

## express

**基于 [Node.js](https://nodejs.org/en/) 平台，快速、开放、极简的 Web 开发框架**

```javascript
// 引入express
const express = require("express")
// 获取服务器的实例(对象)
const app = express()

// 路由
app.get('/', (req, res) => {
//处理数据
})

// 启动服务器
app.listen(80, () => {
  console.log("http://127.0.0.1")
})

```

### express()

托管静态资源

​	express.static(root, [options])

解析请求体

​	express.urlencoded([options])

Router路由

​	express.Router([options])



### 应用程序

```javascript
app.请求方式([path,] (req,res)=>{
	req.params //url动态参数
	req.query  //查询参数 get
    req.get(field)  // 获取请求头
    req.body() // 获取post请求的请求体数据
    req.cookies //用来读取客户端发回的cookie
    
	res.send()   //把内容响应给浏览器
    res.render()  //渲染模板引擎 返回给浏览器
    res.sendStatus() //向客户端发送响应状态吗
    res.status()  //用来设置响应状态吗，但是并不发送
    res.redirect()   //用来发起重定向
    res.setHeader("请求方式", "*") //设置响应头
    res.cookie(名值对格式) //给客户端发送一个cookie

},[callback...])
```

### 中间件

```javascript
// 中间件
use()
//全局
app.use(路劲,(res,req,next)=>{
    //处理数据
    next()
})
// 局部中间件
const z1 = (res, req, next) => {
    //处理数据
    next()
}

// 第一种和第二种等价 z1,z2===[z1,z2]
app.get("/", z1, z2, (res, req) => {
    req.send("你好  GET ")
})
app.get("/luyu", [z1, z2], (res, req) => {
    req.send("你好  GET ")
})
```

### Router 路由

**express.Router([options])**

```javascript
相当于是app.xxx  
// 创建一个路由 可以有多个express.Router([options]) 但只有一个app.xxx
const router = express.Router([options])
router.get("/luyu",(req,res)=>{
    //处理数据
})
// 向外暴露这个 router路由
module.exports = router
```

### 模板引擎

```javascript
 ejs是node中的一款模板引擎，使用步骤：
            1.安装ejs
            2.配置express的模板引擎为ejs
                app.set("view engine", "ejs")
            3.配置模板路径
                app.set("views", path.resolve(__dirname, "views"))
 
    注意，模板引擎需要被express渲染后才能使用
	res.render() 用来渲染一个模板引擎，并将其返回给浏览器
    可以将一个对象作为render的第二个参数传递，这样在模板中可以访问到对象中的数据
    res.render("students", { name: "孙悟空", age: 18, gender: "男" })
    <%= %>在ejs中输出内容时，它会自动对字符串中的特殊符号进行转义 <
    这个设计主要是为了避免 xss 攻击
    <%- %> 直接将内容输出
    <% %>  可以在其中直接编写js代码，js代码会在服务器中执行             
```

## cokie

**cookie是HTTP协议中用来解决无状态问题的技术**

```javascript
/* 
        需要安装中间件来使得express可以解析cookie
            1.安装cookie-parser
                yarn add cookie-parser
            2.引入
                const cookieParser = require("cookie-parser")
            3.设置为中间件
                app.use(cookieParser())
    */
// req.cookies 用来读取客户端发回的cookie
// res.cookie(名值对格式) 给客户端发送一个cookie
```

#### cokie有效期

```javascript
 /*
        cookie是有有效期
            - 默认情况下cookie的有效期就是一次会话（session）
                会话就是一次从打开到关闭浏览器的过程 
            - maxAge 用来设置cookie有效时间，单位是毫秒
    */
app.get("/delete-cookie", (req, res) => {
    // cookie一旦发送给浏览器我们就不能在修改了
    // 但是我们可以通过发送新的同名cookie来替换旧cookie，从而达到修改的目的
 
    res.cookie("name", "", {
        maxAge: 0
    })
 
    res.send("删除Cookie")
})
```

#### cokie 不足

```javascript
 /*
        cookie的不足
            - cookie是由服务器创建，浏览器保存
                每次浏览器访问服务器时都需要将cookie发回
                这就导致我们不能在cookie存放较多的数据
                并且cookie是直接存储在客户端，容易被篡改盗用
            - 注意：
                我们在使用cookie一定不会在cookie存储敏感数据
 
            - 所以为了Cookie的不足，我们希望可以这样
                将用户的数据统一存储在服务器中，
                    每一个用户的数据都有一个对应的id
                    我们只需通过cookie将id发送给浏览器
                    浏览器只需每次访问时将id发回，即可读取到服务器中存储的数据
                    这个技术我们称之为session（会话）                  
    */
```

## session

```javascript
session
                - session是服务器中的一个对象，这个对象用来存储用户的数据
                - 每一个session对象都有一个唯一的id，id会通过cookie的形式发送给客户端
                - 客户端每次访问时只需将存储有id的cookie发回即可获取它在服务器中存储的数据
                - 在express 可以通过 express-session 组件来实现session功能
                - 使用步骤：
                    ① 安装
                        yarn add express-session
                    ② 引入
                        const session = require("....")
                    ③ 设置为中间件
                        app.use(session({...}))
app.use(
  session({
    store: new FileStore({
      //path 指定sessions 本地文件路径
      path: path.join(__dirname, "./sessions"),
      secret: "加密!",
      // session的有效时间 默认一小时
      // ttl: 10,
      // 默认情况下，fileStore会每间隔一小时，清除一次session对象
      // reapInterval 用来指定清除session的间隔，单位秒，默认 1小时
      // reapInterval: 10,
    }),
    // 加密信息
    secret: "小江",
    // cookie: {
    //   maxAge: 1000 * 3600,
    // },
  })
)
/* 
    session是服务器中的一个对象，这个对象用来存储用户的信息
        每一个session都会有一个唯一的id，session创建后，
            id会以cookie的形式发送给浏览器
        浏览器收到以后，每次访问都会将id发回，服务器中就可以根据id找到对应的session
 
    id（cookie） ----> session对象
     
    session什么时候会失效？
        第一种 浏览器的cookie没了
        第二种 服务器中的session对象没了
     
    express-session默认是将session存储到内存中的，所以服务器一旦重启session会自动重置，
        所以我们使用session通常会对session进行一个持久化的操作（写到文件或数据库）
 
    如果将session存储到本文件中：
        - 需要引入一个中间件session-file-store
        - 使用步骤：
            ① 安装
                yarn add session-file-store
            ② 引入
                const FileStore = require("session-file-store")(session) 
            ③ 设置为中间件       
            app.use(
                session({
                    store: new FileStore({}),
                    secret: "dazhaxie"
                })
            )
 
*/
```

csrf攻击
        - 跨站请求伪造
                httphttp://localhost:3000/students/delete?id=3
        
                    - 现在大部分的浏览器的都不会在跨域的情况下自动发送cookie
                这个设计就是为了避免csrf的攻击
                            - 如何解决？
            1. 使用referer头来检查请求的来源
            2. 使用验证码
            3. 尽量使用post请求（结合token）
    
        - token（令牌）
            - 可以在创建表单时随机生成一个令牌
                然后将令牌存储到session中，并通过模板发送给用户
                用户提交表单时，必须将token发回，才可以进行后续操作
                （可以使用uuid来生成token）



# ajax

## Rest

REpresentational State Transfer 
    - 表示层状态的传输
        - Rest实际上就是一种服务器的设计风格
        - 它的主要特点就是，服务器只返回数据
        - 服务器和客户端传输数据时通常会使用JSON作为数据格式
        - 请求的方法：
            GET    加载数据
            POST   新建或添加数据
            PUT    添加或修改数据
            PATCH  修改数据
            DELETE 删除数据
            OPTION 由浏览器自动发送，检查请求的一些权限
        - API（接口） Endpoint（端点）
            GET /user
            POST /user
            DELETE /user/:id

## [xhr(原生方法)](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

```javascript
// 创建一个xhr对象
const xhr = new XMLHttpRequest()
// 设置请求的信息
xhr.open("get", "请求地址")
//发送合适的请求头信息 post必须要
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
// 发送请求 send 添加数据 跟键值对
xhr.send() 
// 将 response 设置为json格式 将json的数据转为对象
// xhr.responseType = "json"
  xhr.addEventListener("load", () => {
      // 监听请求事件 请求成功完成时触发
      if (xhr.readyState === 4 && xhr.status === 200) {
          // 获取服务器响应的数据
          console.log(xhr.response)
        }
      }
  })
```



## [fetch(采用promise apl 升级版)](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)

```javascript
fetch("请求地址",{可选的配置对象}).then((res)=> {
   // 正确确定
	if (res.status === 200) {
	// 将res的json格式数据转为js对象 返回给下一个then
    return res.json()
    } else {
    throw new Error("小江抛出一个错误!")
    }
}).then((res)=>{
     console.log(res)
}) .catch((err) => console.log("服务器出错了 ", err))
```

```javascript
// fetch 第二种写法
try {
	const res = await fetch("http://127.0.0.1/students")
    const data = await res.json()
    console.log(data)
} catch (e) {
     console.log("出错了!" + e)
}
```

### 取消请求

```javascript
// 请求终止
const btn = document.querySelectorAll("button")
      let controller
      btn[0].addEventListener("click", () => {
        // 创建一个AbortController 对象
        controller = new AbortController()

        fetch("http://127.0.0.1/test", {
          // 把 controller 的signal 配置到 fetch中
          signal: controller.signal,
        })
          .then((res) => console.log(res))
          .catch((err) => {
            console.log("出错了!")
          })
      })
      btn[1].addEventListener("click", () => {
        controller && controller.abort() // && 找false 第一个为false 则不看第二个
      })
```

### 配置对象

1. method:请求方法 (默认get)
2. headers:{请求的头信息}
3. body: JSON.stringify({请求的 body 信息}) (get和head 请求没有body)
4. mode:请求的模式
5.  [其他的配置信息](https://developer.mozilla.org/zh-CN/docs/Web/API/fetch)

## [axios(小插件 基本都用这个)](https://www.axios-http.cn/)

### axios基本使用和配置信息

1. 安装npm install axios  

2. ```javascript
   //或者外部引入
   <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
   
   ```

axios 基本和配置选项

```javascript
// 综合的axios请求
axios({
    配置信息
    method: '请求方式',
  	url:"请求地址",
    data:{是作为请求体被发送的数据 对象或者是键值对},
    baseURL: "指定服务器的根目录（路径的前缀）",
    params:{ 用来指定路径中的查询字符串},
    timeout:{过期事件},
    signal:终止请求,
    transformRequest:[function (data, headers) {
    // 允许在向服务器发送前，修改请求数据
    // 对发送的 data 进行任意转换处理
 	// 数组中最后一个函数必须返回一个字符串
    return data;
  }],
   transformResponse:[function (data, headers) {
    // 在传递给 then/catch 前，允许修改响应数据
    return data;
  }],
}).then((result) => {
// result是axios封装过
console.log(result.data)
})
.catch((err) => {
    console.log("出错了！", err)
})


// 响应结构 用then接受
{
  // `data` 由服务器提供的响应
  data: {},
  // `status` 来自服务器响应的 HTTP 状态码
  status: 200,
  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: 'OK',
  // `headers` 是服务器响应头
  // 所有的 header 名称都是小写，而且可以使用方括号语法访问
  // 例如: `response.headers['content-type']`
  headers: {},
  // `config` 是 `axios` 请求的配置信息
  config: {},
  // `request` 是生成此响应的请求
  // 在node.js中它是最后一个ClientRequest实例 (in redirects)，
  // 在浏览器中则是 XMLHttpRequest 实例
  request: {}
}
```

### axios实例

1. axios实例相当于是axios的一个副本，它的功能和axios一样
2. axios的默认配置在实例也同样会生效 但是我可以单独修改axios实例的默认配置

```javascript
// axios.create({}) 这就是axios的实例
const instance = axios.create({
配置信息
});
// 这就是一个axios请求
instance({}).then...
instance.get("请求地址").then...
```

### 默认配置

默认配置可以写在全局下 

axios.defaults.配置选项=值

axios.defaults.headers.common['Authorization'] = 值

### 拦截器

```javascript
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error);
  });
```

### 取消请求

```javascript
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消请求
controller.abort()
```



# [git](https://git-scm.com/)

1. 安装（略）()

2. 配置

   1. 配置name和email

      ``` bash
      git config --global user.name "xxxx"
      git config --global user.email "xxx@xxx.xxx"
      ```

3. 使用git：

   - 查看当前仓库的状态

     ```bash
     git status
     ```

   - 初始化仓库

     ```bash
     git init
     ```

   - 文件状态：

     1. 未跟踪
     2. 已跟踪
     3. 暂存
     4. 未修改
     5. 已修改

   - 未跟踪 → 暂存

     ```bash
     git add <filename> 将文件切换到暂存的状态
     git add * 将所有已修改（未跟踪）的文件暂存
     ```

   - 暂存 → 未修改

     ```bash
     git commit -m "xxxx" 将暂存的文件存储到仓库中
     git commit -a -m "xxxx" 提交所有已修改的文件（未跟踪的文件不会提交）
     ```

   - 未修改 → 修改

     - 修改代码后，文件会变为修改状态

4. 常用的命令

   1. 重置文件

   ```bash
   git restore <filename> # 恢复文件
   git restore --staged <filename> # 取消暂存状态
   ```

   2. 删除文件	

   ```bash
   git rm <filename> # 删除文件
   git rm <filename> -f # 强制删除
   ```

   3. 移动文件

   ```bash
   git mv from to # 移动文件 重命名文件
   ```

   ### 分支

   git在存储文件时，每一次代码代码的提交都会创建一个与之对应的节点，git就是通过一个一个的节点来记录代码的状态的。节点会构成一个树状结构，树状结构就意味着这个树会存在分支，默认情况下仓库只有一个分支，命名为master。在使用git时，可以创建多个分支，分支与分支之间相互独立，在一个分支上修改代码不会影响其他的分支。

   ```bash
   git branch # 查看当前分支
   git branch <branch name> # 创建新的分支
   git branch -d <branch name> # 删除分支
   git switch <branch name> # 切换分支
   git switch -c <branch name> # 创建并切换分支
   git merge <branch name> # 和并分支
   ```

   在开发中，都是在自己的分支上编写代码，代码编写完成后，在将自己的分支合并到主分支中。
   
   ### 变基（rebase）
   
   在开发中除了通过merge来合并分支外，还可以通过变基来完成分支的合并。
   
   我们通过merge合并分支时，在提交记录中会将所有的分支创建和分支合并的过程全部都显示出来，这样当项目比较复杂，开发过程比较波折时，我必须要反复的创建、合并、删除分支。这样一来将会使得我们代码的提交记录变得极为混乱。
   
   原理（变基时发生了什么）：
   
   1. 当我们发起变基时，git会首先找到两条分支的最近的共同祖先
   2. 对比当前分支相对于祖先的历史提交，并且将它们提取出来存储到一个临时文件中
   3. 将当前部分指向目标的基底
   4. 以当前基底开始，重新执行历史操作
   
   变基和merge对于合并分支来说最终的结果是一样的！但是变基会使得代码的提交记录更整洁更清晰！注意！大部分情况下合并和变基是可以互换的，但是如果分支已经提交给了远程仓库，那么这时尽量不要变基。
   
   ### 远程仓库（remote）
   
   目前我对于git所有操作都是在本地进行的。在开发中显然不能这样的，这时我们就需要一个远程的git仓库。远程的git仓库和本地的本质没有什么区别，不同点在于远程的仓库可以被多人同时访问使用，方便我们协同开发。在实际工作中，git的服务器通常由公司搭建内部使用或是购买一些公共的私有git服务器。我们学习阶段，直接使用一些开放的公共git仓库。目前我们常用的库有两个：GitHub和Gitee（码云）
   
   将本地库上传git：
   
   ```bash
   git remote add origin https://github.com/lilichao/git-demo.git
   # git remote add <remote name> <url>
   
   git branch -M main
   # 修改分支的名字的为main
   
   git push -u origin main
   # git push 将代码上传服务器上
   ```
   
   将本地库上传gitee：
   
   ```bash
   git remote add gitee https://gitee.com/ymhold/vue-course.git
   git push -u gitee main
   ```
   
   ### 远程库的操作的命令
   
   ```bash
   git remote # 列出当前的关联的远程库
   git remote add <远程库名> <url> # 关联远程仓库
   git remote remove <远程库名>  # 删除远程库
   git push -u <远程库名> <分支名> # 向远程库推送代码，并和当前分支关联
   git push <远程库> <本地分支>:<远程分支>
   git clone <url> # 从远程库下载代码
   
   git push # 如果本地的版本低于远程库，push默认是推不上去
   git fetch # 要想推送成功，必须先确保本地库和远程库的版本一致，fetch它会从远程仓库下载所有代码，但是它不会将代码和当前分支自动合并
   		 # 使用fetch拉取代码后，必须要手动对代码进行合并	
   git pull  # 从服务器上拉取代码并自动合并 
   
   ```
   
   注意：推送代码之前，一定要先从远程库中拉取最新的代码

	   ### 		tag 标签

- 当头指针没有执行某个分支的头部时，这种状态我们称为分离头指针（HEAD detached），分离头指针的状态下也可以操作操作代码，但是这些操作不会出现在任何的分支上，所以注意不要再分离头指针的状态下来操作仓库。

- 如果非得要回到后边的节点对代码进行操作，则可以选择创建分支后再操作

  ```bash
  git switch -c <分支名> <提交id>
  ```

- 可以为提交记录设置标签，设置标签以后，可以通过标签快速的识别出不同的开发节点：

  ```bash
  git tag
  git tag 版本
  git tag 版本 提交id
  git push 远程仓库 标签名
  git push 远程仓库 --tags
  git tag -d 标签名 # 删除标签
  git push 远程仓库 --delete 标签名 # 删除远程标签
  ```

  ### gitignore

- 默认情况下，git会监视项目中所有内容，但是有些内容比如node_modules目录中的内容，我们不希望它被git所管理。我们可以在项目目录中添加一个`.gitignore`文件，来设置那些需要git忽略的文件。

### 	github的静态页面

- 在github中，可以将自己的静态页面之间部署到github中，它会给我们提供一个地址使得我们的页面变成一个真正的网站，可以供用户访问。
- 要求：
  - 静态页面的分支必须叫做：gh-pages
  - 如果希望页面可以通过xxx.github.io访问，则需要将库的名字配置为xxx.github.io 

### 	docusaurus

- facebook推出的开源的静态的内容管理系统，通过它可以快速的部署一个静态网站

- 使用：

  - 网址：

    - https://docusaurus.io/

  - 安装

    - `npx create-docusaurus@latest my-website classic`

  - 启动项目

    - `npm start`或`yarn start`

  - 构建项目

    - `npm run build`或`yarn build`
  
  - 推送项目到github
  
    - `npm run deploy`
  
  - 配置项目：
  
    - docusaurus.config.js 项目的配置文件
  
  - 添加页面：
  
    - 在docusaurus框架中，页面分成三种：1.page，2.blog，3.doc
  
  - 案例地址：
  
    - https://github.com/lilichao/lilichao.github.io
  
    

# 构建工具

- 当我们习惯了在node中编写代码的方式后，在回到前端编写html、css、js这些东西会感觉到各种的不便。比如：不能放心的使用模块化规范（浏览器兼容性问题）、即使可以使用模块化规范也会面临模块过多时的加载问题。
- 我们就迫切的希望有一款工具可以对代码进行打包，将多个模块打包成一个文件。这样一来即解决了兼容性问题，又解决了模块过多的问题。
- 构建工具就起到这样一个作用，通过构建工具可以将使用ESM规范编写的代码转换为旧的JS语法，这样可以使得所有的浏览器都可以支持代码。

### [Webpack](https://www.webpackjs.com/)

- 使用步骤：
  1. 初始化项目`yarn init -y`
  2. 安装依赖`webpack`、 命令行需要`webpack-cli`
  3. 在项目中创建`src`目录，然后编写代码（index.js）
  4. 执行`npx webpack`来对代码进行打包（打包后观察dist目录） 加个--watch 自动监视代码(这个不常见)
  5. 需要手动在html页面写 <script defer="defer"/>
  
- 配置文件（webpack.config.js）

  ```javascript
  module.exports = {
    // 设置打包的模式,production表示生产模式 development 开发模式
    mode: "production",
  /*
    // 入口文件  entry对象
    // 用来指定打包时的主文件默认 ./src/index.js
    // entry: "./xj/xj.js",
    // 打包多个文件 用数组
    //   entry: ["./src/xxx.js", "./src/xxx.js"],
    // 打包多个文件生产多个文件 属性名就是文件名
    entry: {
      a: "./src/m1.js",
      b: "./src/m2.js",
    },
  */
      
  /*
    //   打包后文件输出的位置  output对象
    output: {
      // filename: "小江.js",// 打包之后的文件名
      filename: "[name].js", // name 是一个变量 就是entry中的属性名
      path: path.resolve(__dirname + "/小江"), //指定打包的目录,必须要绝对路径
      clean: true, // 清空之前的打包目录
    }, 
  */
  
    /* 
    // loader 用于对模块的源代码进行转换 
    // module.rules允许你在 webpack 配置中指定多个 loader
  webpack默认情况下，只会处理js文件，如果我们希望它可以处理其他类型的文件，则要为其引入loader
      以css为例:
          使用css-loader可以处理js中的样式
          使用步骤
              安装:npm i css-loader style-loader -D 
              配置: module: {
                      rules: [
                          {
                          test: /\.css$/i, // 文件匹配规则
                          use: "css-loader", // 用什么处理
                      	},
                      ]
                  }
    */
    module: {
      rules: [
        {
          test: /\.css$/i,
            //css-loader 只负责转换到js 需要 style-loader 把css代码应用到页面
          use: ["style-loader", "css-loader"], //从后往后执行
        },
        {
          test: /\jpg$/i,
          type: "asset/resource", // 图片直接资源类型的数据，可以通过指定type来处理
        },
      ],
    },
  }
  ```

- 在编写js代码时，经常需要使用一些js中的新特性，而新特性在旧的浏览器中兼容性并不好。此时就导致我们无法使用一些新的特性。

- 但是我们现在希望能够使用新的特性，我们可以采用折中的方案。依然使用新特性编写代码，但是代码编写完成时我们可以通过一些工具将新代码转换为旧代码。

- babel就是这样一个工具，可以将新的js语法转换为旧的js，以提高代码的兼容性。

- 我们如果希望在webpack支持babel，则需要向webpack中引入babel的loader

- 使用步骤

  - 安装 `npm install -D babel-loader @babel/core @babel/preset-env`

  - 配置：

     ```javascript
     module: {
       rules: [
         {
           test: /\.m?js$/,
           exclude: /(node_modules|bower_components)/,
           use: {
             loader: 'babel-loader',
             options: {
               presets: ['@babel/preset-env']
             }
           }
         }
       ]
     }
     ```

  - 在package.json中设置兼容列表

     ```json
     "browserslist": [
             "defaults"
      ]
     ```

     https://github.com/browserslist/browserslist

- 插件（plugin）

  - 插件用来为webpack来扩展功能

  - html-webpack-plugin

    - 这个插件可以在打包代码后，自动在打包目录生成html页面

    - 使用步骤：

      1. 安装依赖
      2. 配置插件

      ```javascript
      // 引入插件
      const HTMLPlugin = require("html-webpack-plugin")
      plugins: [
              new HTMLPlugin({
                  // title: "Hello Webpack",
                  template: "./src/index.html"
              })
          ]
      ```

- 开发服务器（webpack-dev-server）

  - 安装：
    - `npm i -D webpack-dev-server`
    
    - 启动：`npm run dev`
    
      ```json
      "scripts":{
          "dev":"webpack serve --open"
      }
      ```

- `devtool:"inline-source-map"`   配置源码的映射

### [Vite](https://cn.vitejs.dev/)

- Vite也是前端的构建工具

- 相较于webpack，vite采用了不同的运行方式：

  - 开发时，并不对代码打包，而是直接采用ESM的方式来运行项目
  - 在项目部署时，在对项目进行打包

- 除了速度外，vite使用起来也更加方便

- 基本使用：

  1. 安装开发依赖 npm i  -D vite

  2. vite的源码目录就是项目根目录

  3. 开发命令：

     npx vite 启动开发服务器

     npm run vite build 打包代码

     npm run vite preview 预览打包后代码

- 使用命令构建项目

  ```bash
  npm create vite@latest
  yarn create vite
  pnpm create vite
  ```

- 配置文件：`vite.config.js`

- 格式：

  ```javascript
  import { defineConfig } from "vite"
  // 引入兼容性的插件
  import legacy from "@vitejs/plugin-legacy"
  export default defineConfig({
    //   defineConfig 要提示就写
    //   兼容就写
    plugins: [
      legacy({
        targets: ["defaults", "IE 11"],
      }),
    ],
  })
  ```
  
  

# [Vue](https://cn.vuejs.org/)

### vue

- vue是一个前端的框架，主要负责帮助我们构建用户的界面
- MVVM： Model(模型) - View(视图) - View Model(视图模型)
- vue负责vm的工作（视图模型），通过vue可以将视图和模型相关联。
  - 当模型发生变化时，视图会自动更新
  - 也可以通过视图去操作模型
- vue思想：
  - 组件化开发
  - 声明式的编程

### HelloWorld

1. 直接在网页中使用（像jQuery一样）

   - `        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>`

2. 使用vite

   - `yarn add vite -D`

3. 代码：

   ```javascript
   // 组件，就是一个普通js对象
   const App = {}
   
   // 创建应用
   const app = createApp(App)
   
   // 挂载到页面
   app.mount("#root")
   ```

4. 自动创建项目
   - `npm init vue@latest`
   - `yarn create vue`

vue响应式数据原理:

通过proxy进行代理



## 网页的渲染

- 浏览器在渲染页面时，做了那些事：

  1. 加载页面的html和css（源码）
  2. html转换为DOM，css转换为CSSOM
  3. 将DOM和CSSOM构建成一课渲染树
  4. 对渲染树进行reflow（回流、重排）（计算元素的位置）
  5. 对网页进行绘制repaint（重绘）

- 渲染树（Render Tree）

  - 从根元素开始检查那些元素可见，以及他们的样式
  - 忽略那些不可见的元素（display:none）

- 重排、回流

  - 计算渲染树中元素的大小和位置
  - 当页面中的元素的大小或位置发生变化时，便会触发页面的重排（回流）
  - width、height、margin、font-size ......
  - 注意：每次修改这类样式都会触发一次重排！所以如果分词修改多个样式会触发重排多次，而重排是非常耗费系统资源的操作（昂贵），重排次数过多后，会导致网页的显示性能变差，在开发时我们应该尽量的减少重排的次数
  - 在现代的前端框架中，这些东西都已经被框架优化过了！所以使用vue、react这些框架这些框架开发时，几乎不需要考虑这些问题，唯独需要注意的时，尽量减少在框架中直接操作DOM

- 重绘

  - 绘制页面
  - 当页面发生变化时，浏览器就会对页面进行重新的绘制

- 例子：

  ```html
  <!DOCTYPE html>
  <html lang="zh">
      <head>
          <meta charset="UTF-8" />
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Document</title>
          <style>
              .box1 {
                  width: 200px;
                  height: 200px;
                  background-color: orange;
              }
  
              .box2 {
                  background-color: tomato;
              }
  
              .box3 {
                  width: 300px;
                  height: 400px;
                  font-size: 20px;
              }
          </style>
      </head>
      <body>
          <button id="btn">点我一下</button>
          <hr />
          <div id="box1" class="box1"></div>
          <script>
              btn.onclick = () => {
                  // box1.classList.add("box2")
                  // 可以通过修改class来间接的影响样式，来减少重排的次数
                  // box1.style.width = "300px"
                  // box1.style.height = "400px"
                  // box1.style.fontSize = "20px"
                  // box1.classList.add("box3")
                  // box1.style.display = "none"
                  // box1.style.width = "300px"
                  // box1.style.height = "400px"
                  // box1.style.fontSize = "20px"
                  // div.style.display = "block"
              }
          </script>
      </body>
  </html>
  
  ```

  

# vue2

## Vue2基础

### 初识Vue

1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；

2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；

3.root容器里的代码被称为【Vue模板】；

4.Vue实例和容器是一一对应的；

5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；

6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；

7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；

### MVVM架构

M：模型(Model) ：data中的数据

V：视图(View) ：模板代码

VM：视图模型(ViewModel)：Vue实例

### el和data打两种写法

```javascript
一个重要的原则：
	由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。
new Vue({
	data(){
        return{
            //函数写法
        }
    }
}).$mount("#app")

new Vue({
el:"#app"
    data:{
        //对象写法
    }
})
```

### Vue2的数据代理

#### Object.defineProperty(obj,属性,配置对象) 

```javascript
//vue2的底层数据代理就是用这个方法
let number = 18
      let person = {
        name: "张三",
        sex: "男",
      }

      Object.defineProperty(person, "age", {
        // value:18,
        // enumerable:true, //控制属性是否可以枚举，默认值是false
        // writable:true, //控制属性是否可以被修改，默认值是false
        // configurable:true //控制属性是否可以被删除，默认值是false

        //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
        get() {
          console.log("有人读取age属性了")
          return number
        },

        //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
        set(value) {
          console.log("有人修改了age属性，且值是", value)
          number = value
        },
      })
```

#### Vue中的数据代理

- Vue中的数据代理：
  - 通过vm对象来代理data对象中属性的操作（读/写）
- Vue中数据代理的好处：
  - 更加方便的操作data中的数据
- 基本原理：
  - 通过Object.defineProperty()把data对象中所有属性添加到vm上。
  - 为每一个添加到vm上的属性，都指定一个getter/setter。
  - 在getter/setter内部去操作（读/写）data中对应的属性。



### 事件处理(methods方法)

#### 事件的基本使用：

- 使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；
- 事件的回调需要配置在**methods**对象中，最终会在vm上；
- methods中配置的函数，不要用箭头函数！否则this就不是vm了；
-  methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；
- @click="demo" 和 @click="demo($event)" 效果一致，但后者可以传参；
- vue 都会默认给我传 event 事件对象

#### Vue中的事件修饰符：(前后顺序)

- prevent：阻止默认事件（常用）；
- stop：阻止事件冒泡（常用）；
- once：事件只触发一次（常用）；
- capture：使用事件的捕获模式；
- self：只有event.target是当前操作的元素时才触发事件；
- passive：事件的默认行为立即执行，无需等待事件回调执行完毕；

#### 键盘事件

- Vue中常用的按键别名： 
  - 回车 => enter
  - 删除 => delete (捕获“删除”和“退格”键)
  - 退出 => esc
  - 空格 => space
  - 换行 => tab (特殊，必须配合keydown去使用)
  - 上 => up	下 => down	左 => left	右 => right

- Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）

- 系统修饰键（用法特殊）：ctrl、alt、shift、meta

  - 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。

  - 配合keydown使用：正常触发事件。

- 也可以使用keyCode去指定具体的按键（不推荐）

- Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名

### 计算属性 (computed)

- 定义：要用的属性不存在，要通过已有属性计算得来。
- 原理：底层借助了Objcet.defineproperty方法提供的getter和setter。
- get函数什么时候执行？
  - 初次读取时会执行一次。
  - 当依赖的数据发生改变时会被再次调用。
- 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
- 备注：
  - 计算属性最终会出现在vm上，直接读取使用即可。
  - 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。

```javascript
computed:{
    fullName:{
        // get 初次读取 被人读取 依赖发生改变 都会调用
        get(){
            console.log("get被调用")
        	return 返回值     
        },
        // set 当fullName被赋值调用
        set(value){
           ...
        }
    }
}
// 简写
computed:{
    fullName(){
		console.log('get被调用了')
		return 返回值
	}
} 
```

### 监视属性(watch)

- 当被监视的属性变化时, 回调函数自动调用, 进行相关操作
- 监视的属性必须存在，才能进行监视！！
- 监视的两种写法：
  - new Vue时传入watch配置
  - 通过vm.$watch监视

```javascript
//第一种
watch:{
	'属性':{
        //deep:true,// 可以监测对象内部值改变（多层）
        immediate:true, //初始化时让handler调用一下
		//handler什么时候调用？当属性发生改变时。
		handler(newValue,oldValue){ // 新值 旧值
			console.log('属性被修改了',newValue,oldValue)
		}
    }
}
//第二种
$watch("属性", {
      handler(newValue, oldValue) {
        console.log("属性被修改了", newValue, oldValue)
	},
})
//简写
属性(newValue, oldValue){
    console.log("属性被修改了", newValue, oldValue, this)
}
vm.$watch('属性',(newValue,oldValue)=>{
	...
})
```

#### 深度监视：

- Vue中的watch默认不监测对象内部值的改变（一层）。
- 配置deep:true可以监测对象内部值改变（多层）。
- 备注：
  - Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！
  - 使用watch时根据数据的具体结构，决定是否采用深度监视。

#### 计算属性和监视属性的区别

- computed能完成的功能，watch都可以完成。
- watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。
- 两个重要的小原则：
  - 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。
  - 所有不被Vue所管理的函数（回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。

### 绑定样式

- class样式
  - 字符串写法适用于：类名不确定，要动态获取。
  - 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。
  - 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
- style样式
  - :style="{fontSize: xxx}"其中xxx是动态值。
  - :style="[a,b]"其中a、b是样式对象。

### 内置指令

v-text: 文本内容

v-html: 识别标签 xss攻击

v-cloak: (**没值** 使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。)

v-once: (初次渲染 之后变成静态 **没值**)

v-pre: (跳过编译 **没值**)

v-bind: 简写 : (单项数据绑定)

v-on: 简写 @

v-model: (双向数据绑定 默认获取value)

v-show= (切换快 隐藏)

v-if=    v-else=   v-else-if=    (加载快 移除)

### 自定义指令

指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。

```javascript
//局部
directives:{
    //函数式 
    指令名(element, binding){
	console.log("big", this) //注意此处的this是window
	//1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析
    }
    //对象式
    指令名:{
        bind(element, binding){}// 指令与元素成功绑定 (一上来)
        inserted(element, binding){} // 指令所在元素被插入页面时
        update(element, binding){} // 指令所在的模板被重新解析时
    }
}
//全局
Vue.directive("指令名",{})
Vue.directive("指令名",()=>{})
```

### 列表渲染

v-for 		遍历数组 对象 字符串 数字 

语法:  v-for="(item, index) in xxx" :key="唯一标识"

#### key的原理

- 虚拟DOM中key的作用：

  - key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

- 对比规则：

  - 旧虚拟DOM中找到了与新虚拟DOM相同的key：
    - 若虚拟DOM中内容没变, 直接使用之前的真实DOM！
    - 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。
  - 旧虚拟DOM中未找到与新虚拟DOM相同的key
    - 创建新的真实DOM，随后渲染到到页面。

- 用index作为key可能会引发的问题：

  - 若对数据进行：逆序添加、逆序删除等破坏顺序操作:

    会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

  - 如果结构中还包含输入类的DOM：

    会产生错误DOM更新 ==> 界面有问题。

- 开发中如何选择key?:

  - 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
  - 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
            使用index作为key是没有问题的。

### Vue监测数据的原理

- vue会监视data中所有层次的数据。
- 如何监测对象中的数据？
  - 通过setter实现监视，且要在new Vue时就传入要监测的数据。
    - 对象中后追加的属性，Vue默认不做响应式处理
    - 如需给后添加的属性做响应式，请使用如下API：
      - Vue.set(target，propertyName/index，value) 或 
      - vm.$set(target，propertyName/index，value)
-  如何监测数组中的数据？
  - 通过包裹数组更新元素的方法实现，本质就是做了两件事：
    - 调用原生对应的方法对数组进行更新。
    - 重新解析模板，进而更新页面。
- 在Vue修改数组中的某个元素一定要用如下方法：
  - 使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
  - Vue.set() 或 vm.$set()
- 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！

### 收集表单数据  

若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。

若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。

若：<input type="checkbox"/>

- 没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）
- 配置input的value属性:
  - v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
  - v-model的初始值是数组，那么收集的的就是value组成的数组

备注：v-model的三个修饰符：

- lazy：失去焦点再收集数据
- number：输入字符串转为有效的数字
- trim：输入首尾空格过滤

### 过滤器(局部filters 全局Vue.filter)

- 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
- 语法：
  - 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
  - 使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = "xxx | 过滤器名"
- 备注：
  - 过滤器也可以接收额外参数、多个过滤器也可以串联
  - 并没有改变原本的数据, 是产生新的对应的数据

```javascript
 filters: {
	过滤器名字(value, str = "YYYY年MM月DD日 HH:mm:ss") { // value是前一个属性的值 第二个是过滤器的参数
    return dayjs(value).format(str)
	},
}
//全局
Vue.filter("glq", function (value) {
      return value.slice(0, 4)
})
```

### 生命周期

生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。

生命周期函数中的this指向是vm 或 组件实例对象。

四对钩子函数

- 初始化

  - beforeCreate												created


- 生成虚拟DOM 解析把真实DOM放入页面

  - beforeMount												**mounted** (初始化操作)

- 更新

  - beforeUpdate												updated

- 销毁

  - **beforeDestroy**	(收尾工作)										destroyed



**生命周期的流程图**

![image-20230215124525411](C:\Users\luyu\AppData\Roaming\Typora\typora-user-images\image-20230215124525411.png)

### 非单文件组件

定义组件 注册组件 使用组件

定义组件: 使用Vue.extend(配置) 其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；不写el data写成函数

注册组件:局部:new Vue的时候传入components选项 全局:靠Vue.component('组件名',组件)

使用组件: <Xj></Xj>



Vue.extend(配置) 会返回一个值 VueComponent的实例对象 (原型是VueComponent的原型对象的原型对象是Vue的原型对象)

### 单文件组件

用脚手架 现在都用 **vite**

##  脚手架文件结构

	├── node_modules 
	├── public
	│   ├── favicon.ico: 页签图标
	│   └── index.html: 主页面
	├── src
	│   ├── assets: 存放静态资源
	│   │   └── logo.png
	│   │── component: 存放组件
	│   │   └── HelloWorld.vue
	│   │── App.vue: 汇总所有组件
	│   │── main.js: 入口文件
	├── .gitignore: git版本管制忽略的配置
	├── babel.config.js: babel的配置文件
	├── package.json: 应用包配置文件 
	├── README.md: 应用描述文件
	├── package-lock.json：包版本控制文件

## 关于不同版本的Vue

1. vue.js与vue.runtime.xxx.js的区别：
   1. vue.js是完整版的Vue，包含：核心功能 + 模板解析器。
   2. vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。
2. 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。

## vue.config.js配置文件

1. 使用vue inspect > output.js可以查看到Vue脚手架的默认配置。
2. 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh

## ref属性

1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
3. 使用方式：
   1. 打标识：```<h1 ref="xxx">.....</h1>``` 或 ```<School ref="xxx"></School>```
   2. 获取：```this.$refs.xxx```

## props配置项

1. 功能：让组件接收外部传过来的数据

2. 传递数据：```<Demo name="xxx"/>```

3. 接收数据：

   1. 第一种方式（只接收）：```props:['name'] ```

   2. 第二种方式（限制类型）：```props:{name:String}```

   3. 第三种方式（限制类型、限制必要性、指定默认值）：

      ```js
      props:{
      	name:{
      	type:String, //类型
      	required:true, //必要性
      	default:'老王' //默认值
      	}
      }
      ```

   > 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。

## mixin(混入)

1. 功能：可以把多个组件共用的配置提取成一个混入对象

2. 使用方式：

   第一步定义混合：

   ```
   {
       data(){....},
       methods:{....}
       ....
   }
   ```

   第二步使用混入：

   ​	全局混入：```Vue.mixin(xxx)```
   ​	局部混入：```mixins:['xxx']	```

## 插件

1. 功能：用于增强Vue

2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。

3. 定义插件：

   ```js
   对象.install = function (Vue, options) {
       // 1. 添加全局过滤器
       Vue.filter(....)
   
       // 2. 添加全局指令
       Vue.directive(....)
   
       // 3. 配置全局混入(合)
       Vue.mixin(....)
   
       // 4. 添加实例方法
       Vue.prototype.$myMethod = function () {...}
       Vue.prototype.$myProperty = xxxx
   }
   ```

4. 使用插件：```Vue.use()```

## scoped样式

1. 作用：让样式在局部生效，防止冲突。
2. 写法：```<style scoped>```

## 总结TodoList案例

1. 组件化编码流程：

   ​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。

   ​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：

   ​			1).一个组件在用：放在组件自身即可。

   ​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。

   ​	(3).实现交互：从绑定事件开始。

2. props适用于：

   ​	(1).父组件 ==> 子组件 通信

   ​	(2).子组件 ==> 父组件 通信（要求父先给子一个函数）

3. 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！

4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。

## webStorage

1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）

2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。

3. 相关API：

   1. ```xxxxxStorage.setItem('key', 'value');```
      	该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。

   2. ```xxxxxStorage.getItem('person');```

      ​		该方法接受一个键名作为参数，返回键名对应的值。

   3. ```xxxxxStorage.removeItem('key');```

      ​		该方法接受一个键名作为参数，并把该键名从存储中删除。

   4. ``` xxxxxStorage.clear()```

      ​		该方法会清空存储中的所有数据。

4. 备注：

   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。
   2. LocalStorage存储的内容，需要手动清除才会消失。
   3. ```xxxxxStorage.getItem(xxx)```如果xxx对应的value获取不到，那么getItem的返回值是null。
   4. ```JSON.parse(null)```的结果依然是null。

## 组件的自定义事件

1. 一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===> 父组件</strong>

2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。

3. 绑定自定义事件：

   1. 第一种方式，在父组件中：```<Demo @atguigu="test"/>```  或 ```<Demo v-on:atguigu="test"/>```

   2. 第二种方式，在父组件中：

      ```js
      <Demo ref="demo"/>
      ......
      mounted(){
         this.$refs.xxx.$on('atguigu',this.test)
      }
      ```

   3. 若想让自定义事件只能触发一次，可以使用```once```修饰符，或```$once```方法。

4. 触发自定义事件：```this.$emit('atguigu',数据)```		

5. 解绑自定义事件```this.$off('atguigu')```

6. 组件上也可以绑定原生DOM事件，需要使用```native```修饰符。

7. 注意：通过```this.$refs.xxx.$on('atguigu',回调)```绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！

## 全局事件总线（GlobalEventBus）

1. 一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。

2. 安装全局事件总线：

   ```js
   new Vue({
   	......
   	beforeCreate() {
   		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
   	},
       ......
   }) 
   ```

3. 使用事件总线：

   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span>

      ```js
      methods(){
        demo(data){......}
      }
      ......
      mounted() {
        this.$bus.$on('xxxx',this.demo)
      }
      ```

   2. 提供数据：```this.$bus.$emit('xxxx',数据)```

4. 最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。

## 消息订阅与发布（pubsub）

1. 一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。

2. 使用步骤：

   1. 安装pubsub：```npm i pubsub-js```

   2. 引入: ```import pubsub from 'pubsub-js'```

   3. 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span>

      ```js
      methods(){
        demo(data){......}
      }
      ......
      mounted() {
        this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
      }
      ```

   4. 提供数据：```pubsub.publish('xxx',数据)```

   5. 最好在beforeDestroy钩子中，用```PubSub.unsubscribe(pid)```去<span style="color:red">取消订阅。</span>

## nextTick

1. 语法：```this.$nextTick(回调函数)```
2. 作用：在下一次 DOM 更新结束后执行其指定的回调。
3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。

## Vue封装的过度与动画

1. 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。

2. 图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" />

3. 写法：

   1. 准备好样式：

      - 元素进入的样式：
        1. v-enter：进入的起点
        2. v-enter-active：进入过程中
        3. v-enter-to：进入的终点
      - 元素离开的样式：
        1. v-leave：离开的起点
        2. v-leave-active：离开过程中
        3. v-leave-to：离开的终点

   2. 使用```<transition>```包裹要过度的元素，并配置name属性：

      ```vue
      <transition name="hello">
      	<h1 v-show="isShow">你好啊！</h1>
      </transition>
      ```

   3. 备注：若有多个元素需要过度，则需要使用：```<transition-group>```，且每个元素都要指定```key```值。

## vue脚手架配置代理

### 方法一

​	在vue.config.js中添加如下配置：

```js
devServer:{
  proxy:"http://localhost:5000"
}
```

说明：

1. 优点：配置简单，请求资源时直接发给前端（8080）即可。
2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。
3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）

### 方法二

​	编写vue.config.js配置具体代理规则：

```js
module.exports = {
	devServer: {
      proxy: {
      '/api1': {// 匹配所有以 '/api1'开头的请求路径
        target: 'http://localhost:5000',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api1': ''}
      },
      '/api2': {// 匹配所有以 '/api2'开头的请求路径
        target: 'http://localhost:5001',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api2': ''}
      }
    }
  }
}
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
```

说明：

1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。
2. 缺点：配置略微繁琐，请求资源时必须加前缀。

## 插槽

1. 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===> 子组件</strong> 。

2. 分类：默认插槽、具名插槽、作用域插槽

3. 使用方式：

   1. 默认插槽：

      ```vue
      父组件中：
              <Category>
                 <div>html结构1</div>
              </Category>
      子组件中：
              <template>
                  <div>
                     <!-- 定义插槽 -->
                     <slot>插槽默认内容...</slot>
                  </div>
              </template>
      ```

   2. 具名插槽：

      ```vue
      父组件中：
              <Category>
                  <template slot="center">
                    <div>html结构1</div>
                  </template>
      
                  <template v-slot:footer>
                     <div>html结构2</div>
                  </template>
              </Category>
      子组件中：
              <template>
                  <div>
                     <!-- 定义插槽 -->
                     <slot name="center">插槽默认内容...</slot>
                     <slot name="footer">插槽默认内容...</slot>
                  </div>
              </template>
      ```

   3. 作用域插槽：

      1. 理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）

      2. 具体编码：

         ```vue
         父组件中：
         		<Category>
         			<template scope="scopeData">
         				<!-- 生成的是ul列表 -->
         				<ul>
         					<li v-for="g in scopeData.games" :key="g">{{g}}</li>
         				</ul>
         			</template>
         		</Category>
         
         		<Category>
         			<template slot-scope="scopeData">
         				<!-- 生成的是h4标题 -->
         				<h4 v-for="g in scopeData.games" :key="g">{{g}}</h4>
         			</template>
         		</Category>
         子组件中：
                 <template>
                     <div>
                         <slot :games="games"></slot>
                     </div>
                 </template>
         		
                 <script>
                     export default {
                         name:'Category',
                         props:['title'],
                         //数据在子组件自身
                         data() {
                             return {
                                 games:['红色警戒','穿越火线','劲舞团','超级玛丽']
                             }
                         },
                     }
                 </script>
         ```

   ```
   
   ```

## Vuex

### 1.概念

​	在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。

### 2.何时使用？

​		多个组件需要共享数据时

### 3.搭建vuex环境

1. 创建文件：```src/store/index.js```

   ```js
   //引入Vue核心库
   import Vue from 'vue'
   //引入Vuex
   import Vuex from 'vuex'
   //应用Vuex插件
   Vue.use(Vuex)
   
   //准备actions对象——响应组件中用户的动作
   const actions = {}
   //准备mutations对象——修改state中的数据
   const mutations = {}
   //准备state对象——保存具体的数据
   const state = {}
   
   //创建并暴露store
   export default new Vuex.Store({
   	actions,
   	mutations,
   	state
   })
   ```

2. 在```main.js```中创建vm时传入```store```配置项

   ```js
   ......
   //引入store
   import store from './store'
   ......
   
   //创建vm
   new Vue({
   	el:'#app',
   	render: h => h(App),
   	store
   })
   ```

###    4.基本使用

1. 初始化数据、配置```actions```、配置```mutations```，操作文件```store.js```

   ```js
   //引入Vue核心库
   import Vue from 'vue'
   //引入Vuex
   import Vuex from 'vuex'
   //引用Vuex
   Vue.use(Vuex)
   
   const actions = {
       //响应组件中加的动作
   	jia(context,value){
   		// console.log('actions中的jia被调用了',miniStore,value)
   		context.commit('JIA',value)
   	},
   }
   
   const mutations = {
       //执行加
   	JIA(state,value){
   		// console.log('mutations中的JIA被调用了',state,value)
   		state.sum += value
   	}
   }
   
   //初始化数据
   const state = {
      sum:0
   }
   
   //创建并暴露store
   export default new Vuex.Store({
   	actions,
   	mutations,
   	state,
   })
   ```

2. 组件中读取vuex中的数据：```$store.state.sum```

3. 组件中修改vuex中的数据：```$store.dispatch('action中的方法名',数据)``` 或 ```$store.commit('mutations中的方法名',数据)```

   >  备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写```dispatch```，直接编写```commit```

### 5.getters的使用

1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。

2. 在```store.js```中追加```getters```配置

   ```js
   ......
   
   const getters = {
   	bigSum(state){
   		return state.sum * 10
   	}
   }
   
   //创建并暴露store
   export default new Vuex.Store({
   	......
   	getters
   })
   ```

3. 组件中读取数据：```$store.getters.bigSum```

### 6.四个map方法的使用

1. <strong>mapState方法：</strong>用于帮助我们映射```state```中的数据为计算属性

   ```js
   computed: {
       //借助mapState生成计算属性：sum、school、subject（对象写法）
        ...mapState({sum:'sum',school:'school',subject:'subject'}),
            
       //借助mapState生成计算属性：sum、school、subject（数组写法）
       ...mapState(['sum','school','subject']),
   },
   ```

2. <strong>mapGetters方法：</strong>用于帮助我们映射```getters```中的数据为计算属性

   ```js
   computed: {
       //借助mapGetters生成计算属性：bigSum（对象写法）
       ...mapGetters({bigSum:'bigSum'}),
   
       //借助mapGetters生成计算属性：bigSum（数组写法）
       ...mapGetters(['bigSum'])
   },
   ```

3. <strong>mapActions方法：</strong>用于帮助我们生成与```actions```对话的方法，即：包含```$store.dispatch(xxx)```的函数

   ```js
   methods:{
       //靠mapActions生成：incrementOdd、incrementWait（对象形式）
       ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
   
       //靠mapActions生成：incrementOdd、incrementWait（数组形式）
       ...mapActions(['jiaOdd','jiaWait'])
   }
   ```

4. <strong>mapMutations方法：</strong>用于帮助我们生成与```mutations```对话的方法，即：包含```$store.commit(xxx)```的函数

   ```js
   methods:{
       //靠mapActions生成：increment、decrement（对象形式）
       ...mapMutations({increment:'JIA',decrement:'JIAN'}),
       
       //靠mapMutations生成：JIA、JIAN（对象形式）
       ...mapMutations(['JIA','JIAN']),
   }
   ```

> 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。

### 7.模块化+命名空间

1. 目的：让代码更好维护，让多种数据分类更加明确。

2. 修改```store.js```

   ```javascript
   const countAbout = {
     namespaced:true,//开启命名空间
     state:{x:1},
     mutations: { ... },
     actions: { ... },
     getters: {
       bigSum(state){
          return state.sum * 10
       }
     }
   }
   
   const personAbout = {
     namespaced:true,//开启命名空间
     state:{ ... },
     mutations: { ... },
     actions: { ... }
   }
   
   const store = new Vuex.Store({
     modules: {
       countAbout,
       personAbout
     }
   })
   ```

3. 开启命名空间后，组件中读取state数据：

   ```js
   //方式一：自己直接读取
   this.$store.state.personAbout.list
   //方式二：借助mapState读取：
   ...mapState('countAbout',['sum','school','subject']),
   ```

4. 开启命名空间后，组件中读取getters数据：

   ```js
   //方式一：自己直接读取
   this.$store.getters['personAbout/firstPersonName']
   //方式二：借助mapGetters读取：
   ...mapGetters('countAbout',['bigSum'])
   ```

5. 开启命名空间后，组件中调用dispatch

   ```js
   //方式一：自己直接dispatch
   this.$store.dispatch('personAbout/addPersonWang',person)
   //方式二：借助mapActions：
   ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
   ```

6. 开启命名空间后，组件中调用commit

   ```js
   //方式一：自己直接commit
   this.$store.commit('personAbout/ADD_PERSON',person)
   //方式二：借助mapMutations：
   ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
   ```

 ## 路由

1. 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。
2. 前端路由：key是路径，value是组件。

### 1.基本使用

1. 安装vue-router，命令：```npm i vue-router```

2. 应用插件：```Vue.use(VueRouter)```

3. 编写router配置项:

   ```js
   路径: src/router/index.js
   //引入VueRouter
   import VueRouter from 'vue-router'
   //引入Luyou 组件
   import About from '../pages/About'
   import Home from '../pages/Home'
   
   //创建router实例对象，去管理一组一组的路由规则
   const router = new VueRouter({
   	routes:[
   		{
   			path:'/about',
   			component:About
   		},
   		{
   			path:'/home',
   			component:Home
   		}
   	]
   })
   
   //暴露router
   export default router
   ```

4. 实现切换（active-class可配置高亮样式）

   ```vue
   <router-link active-class="active" to="/about">About</router-link>
   ```

5. 指定展示位置

   ```vue
   <router-view></router-view>
   ```

### 2.几个注意点

1. 路由组件通常存放在```pages```文件夹，一般组件通常存放在```components```文件夹。
2. 通过切换，“隐藏”了的路由组件，**默认是被销毁掉的**，需要的时候再去挂载。
3. 每个组件都有自己的```$route```属性，里面存储着自己的路由信息。
4. 整个应用只有一个router，可以通过组件的```$router```属性获取到。

### 3.多级路由（多级路由）

1. 配置路由规则，使用children配置项：

   ```js
   routes:[
   	{
   		path:'/about',
   		component:About,
   	},
   	{
   		path:'/home',
   		component:Home,
   		children:[ //通过children配置子级路由
   			{
   				path:'news', //此处一定不要写：/news
   				component:News
   			},
   			{
   				path:'message',//此处一定不要写：/message
   				component:Message
   			}
   		]
   	}
   ]
   ```

2. 跳转（要写完整路径）：

   ```vue
   <router-link to="/home/news">News</router-link>
   ```

### 4.路由的query参数

1. 传递参数

   ```vue
   <!-- 跳转并携带query参数，to的字符串写法 -->
   <router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link>
   				
   <!-- 跳转并携带query参数，to的对象写法 -->
   <router-link 
   	:to="{
   		path:'/home/message/detail',
   		query:{
   		    id:666,
               title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

2. 接收参数：

   ```js
   $route.query.id
   $route.query.title
   ```

### 5.命名路由

1. 作用：可以简化路由的跳转。

2. 如何使用

   1. 给路由命名：

      ```js
      {
      	path:'/demo',
      	component:Demo,
      	children:[
      		{
      			path:'test',
      			component:Test,
      			children:[
      				{
                          name:'hello' //给路由命名
      					path:'welcome',
      					component:Hello,
      				}
      			]
      		}
      	]
      }
      ```

   2. 简化跳转：

      ```vue
      <!--简化前，需要写完整的路径 -->
      <router-link to="/demo/test/welcome">跳转</router-link>
      
      <!--简化后，直接通过名字跳转 -->
      <router-link :to="{name:'hello'}">跳转</router-link>
      
      <!--简化写法配合传递参数 -->
      <router-link 
      	:to="{
      		name:'hello',
      		query:{
      		   id:666,
                  title:'你好'
      		}
      	}"
      >跳转</router-link>
      ```

### 6.路由的params参数

1. 配置路由，声明接收params参数

   ```js
   {
   	path:'/home',
   	component:Home,
   	children:[
   		{
   			path:'news',
   			component:News
   		},
   		{
   			component:Message,
   			children:[
   				{
   					name:'xiangqing',
   					path:'detail/:id/:title', //使用占位符声明接收params参数
   					component:Detail
   				}
   			]
   		}
   	]
   }
   ```

2. 传递参数

   ```vue
   <!-- 跳转并携带params参数，to的字符串写法 -->
   <router-link :to="/home/message/detail/666/你好">跳转</router-link>
   				
   <!-- 跳转并携带params参数，to的对象写法 -->
   <router-link 
   	:to="{
   		name:'xiangqing',
   		params:{
   		   id:666,
              title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

   > 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！

3. 接收参数：

   ```js
   $route.params.id
   $route.params.title
   ```

### 7.路由的props配置

作用：让路由组件更方便的收到参数

```js
{
	name:'xiangqing',
	path:'detail/:id',
	component:Detail,

	//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
	// props:{a:900}

	//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
	// props:true
	
	//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
	props(route){
		return {
			id:route.query.id,
			title:route.query.title
		}
	}
}
```

### 8.```<router-link>```的replace属性

1. 作用：控制路由跳转时操作浏览器历史记录的模式
2. 浏览器的历史记录有两种写入方式：分别为```push```和```replace```，```push```是追加历史记录，```replace```是替换当前记录。路由跳转时候默认为```push```
3. 如何开启```replace```模式：```<router-link replace .......>News</router-link>```

### 9.编程式路由导航

1. 作用：不借助```<router-link> ```实现路由跳转，让路由跳转更加灵活

2. 具体编码：

   ```js
   //$router的两个API
   this.$router.push({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   
   this.$router.replace({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   this.$router.forward() //前进
   this.$router.back() //后退
   this.$router.go() //可前进也可后退
   ```
   
   下一级路由 接受数据是用props配置项

### 10.缓存路由组件

1. 作用：让不展示的路由组件保持挂载，不被销毁。

2. 具体编码：

   ```vue
   <keep-alive include="News"> 
       <router-view></router-view>
   </keep-alive>
   // 可写多个
   <keep-alive :include="['News',...]">
   
   ```

### 11.两个新的生命周期钩子

1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。
2. 具体名字：
   1. ```activated```路由组件被激活时触发。
   2. ```deactivated```路由组件失活时触发。

### 12.路由守卫

1. 作用：对路由进行权限控制

2. 分类：全局守卫、独享守卫、组件内守卫

3. 全局守卫:

   ```js
   //全局前置守卫：初始化时执行、每次路由切换前执行
   router.beforeEach((to,from,next)=>{
   	console.log('beforeEach',to,from)
   	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   		if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则
   			next() //放行
   		}else{
   			alert('暂无权限查看')
   			// next({name:'guanyu'})
   		}
   	}else{
   		next() //放行
   	}
   })
   
   //全局后置守卫：初始化时执行、每次路由切换后执行
   router.afterEach((to,from)=>{
   	console.log('afterEach',to,from)
   	if(to.meta.title){ 
   		document.title = to.meta.title //修改网页的title
   	}else{
   		document.title = 'vue_test'
   	}
   })
   ```

4. 独享守卫:

   ```js
   beforeEnter(to,from,next){
   	console.log('beforeEnter',to,from)
   	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   		if(localStorage.getItem('school') === 'atguigu'){
   			next()
   		}else{
   			alert('暂无权限查看')
   			// next({name:'guanyu'})
   		}
   	}else{
   		next()
   	}
   }
   ```

5. 组件内守卫：

   ```js
   //进入守卫：通过路由规则，进入该组件时被调用
   beforeRouteEnter (to, from, next) {
   },
   //离开守卫：通过路由规则，离开该组件时被调用
   beforeRouteLeave (to, from, next) {
   }
   ```

### 13.路由器的两种工作模式

1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。

2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。

3. hash模式：

   1. 地址中永远带着#号，不美观 。
   2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
   3. 兼容性较好。

4. history模式：

   1. 地址干净，美观 。
   2. 兼容性和hash模式相比略差。
   3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。
      1. 解决方法 npm i connect-history-api-fallback 
      2. 调用 app.use(history()); 在静态资源前调用
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
# Vue3快速上手

   <img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />

   

   ## 1.Vue3简介

   - 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）
   - 耗时2年多、[2600+次提交](https://github.com/vuejs/vue-next/graphs/commit-activity)、[30+个RFC](https://github.com/vuejs/rfcs/tree/master/active-rfcs)、[600+次PR](https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+)、[99位贡献者](https://github.com/vuejs/vue-next/graphs/contributors) 
   - github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0

   ## 2.Vue3带来了什么

   ### 1.性能的提升

   - 打包大小减少41%
   
   - 初次渲染快55%, 更新渲染快133%
   
   - 内存减少54%
   
     ......

   ### 2.源码的升级

   - 使用Proxy代替defineProperty实现响应式
   
   - 重写虚拟DOM的实现和Tree-Shaking
   
     ......

   ### 3.拥抱TypeScript

   - Vue3可以更好的支持TypeScript

   ### 4.新的特性

   1. Composition API（组合API）
   
      - setup配置
      - ref与reactive
      - watch与watchEffect
      - provide与inject
      - ......
   2. 新的内置组件
      - Fragment 
      - Teleport
      - Suspense
   3. 其他改变
   
      - 新的生命周期钩子
      - data 选项应始终被声明为一个函数
      - 移除keyCode支持作为 v-on 的修饰符
      - ......

   # 一、创建Vue3.0工程

   ## 1.使用 vue-cli 创建

   官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create

   ```bash
   ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
   vue --version
   ## 安装或者升级你的@vue/cli
   npm install -g @vue/cli
   ## 创建
   vue create vue_test
   ## 启动
   cd vue_test
   npm run serve
   ```

   ## 2.使用 vite 创建

   官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite

   vite官网：https://vitejs.cn

   - 什么是vite？—— 新一代前端构建工具。
   - 优势如下：
     - 开发环境中，无需打包操作，可快速的冷启动。
     - 轻量快速的热重载（HMR）。
     - 真正的按需编译，不再等待整个应用编译完成。
   - 传统构建 与 vite构建对比图

   <img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" />

   ```bash
   ## 创建工程
   npm init vite-app <project-name>
   ## 进入工程目录
   cd <project-name>
   ## 安装依赖
   npm install
   ## 运行
   npm run dev
   ```

   # 二、常用 Composition API

   官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html

   ## 1.拉开序幕的setup

   1. 理解：Vue3.0中一个新的配置项，值为一个函数。
   2. setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。
   3. 组件中所用到的：数据、方法等等，均要配置在setup中。
   4. setup函数的两种返回值：
      1. 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）
      2. <span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span>
   5. 注意点：
      1. 尽量不要与Vue2.x配置混用
         - Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。
         - 但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。
         - 如果有重名, setup优先。
      2. setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）

   ##  2.ref函数

   - 作用: 定义一个响应式的数据
   - 语法: ```const xxx = ref(initValue)``` 
     - 创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。
     - JS中操作数据： ```xxx.value```
     - 模板中读取数据: 不需要.value，直接：```<div>{{xxx}}</div>```
   - 备注：
     - 接收的数据可以是：基本类型、也可以是对象类型。
     - 基本类型的数据：响应式依然是靠``Object.defineProperty()``的```get```与```set```完成的。
     - 对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— ```reactive```函数。

   ## 3.reactive函数

   - 作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用```ref```函数）
   - 语法：```const 代理对象= reactive(源对象)```接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong>
   - reactive定义的响应式数据是“深层次的”。
   - 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。

   ## 4.Vue3.0中的响应式原理

   ### vue2.x的响应式

   - 实现原理：
   
     - 对象类型：通过```Object.defineProperty()```对属性的读取、修改进行拦截（数据劫持）。
     
     - 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。
     
       ```js
       Object.defineProperty(data, 'count', {
           get () {}, 
           set () {}
       })
       ```
   
   - 存在问题：
   
     - 新增属性、删除属性, 界面不会更新。
     - 直接通过下标修改数组, 界面不会自动更新。

   ### Vue3.0的响应式

   - 实现原理: 
   
     - 通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。
     
     - 通过Reflect（反射）:  对源对象的属性进行操作。
     
     - MDN文档中描述的Proxy与Reflect：
     
       - Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
     
       - Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect
     
         ```js
         new Proxy(data, {
         	// 拦截读取属性值
             get (target, prop) {
             	return Reflect.get(target, prop)
             },
             // 拦截设置属性值或添加新属性
             set (target, prop, value) {
             	return Reflect.set(target, prop, value)
             },
             // 拦截删除属性
             deleteProperty (target, prop) {
             	return Reflect.deleteProperty(target, prop)
             }
         })
         
         proxy.name = 'tom'   
         ```

   ## 5.reactive对比ref

   -  从定义数据角度对比：
      -  ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。
      -  reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。
      -  备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过```reactive```转为<strong style="color:#DD5145">代理对象</strong>。
   -  从原理角度对比：
      -  ref通过``Object.defineProperty()``的```get```与```set```来实现响应式（数据劫持）。
      -  reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。
   -  从使用角度对比：
      -  ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong>```.value```，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong>```.value```。
      -  reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong>```.value```。

   ## 6.setup的两个注意点

   - setup执行的时机
     - 在beforeCreate之前执行一次，this是undefined。
   
   - setup的参数
     - props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。
     - context：上下文对象
       - attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 ```this.$attrs```。
       - slots: 收到的插槽内容, 相当于 ```this.$slots```。
       - emit: 分发自定义事件的函数, 相当于 ```this.$emit```。


   ## 7.计算属性与监视

   ### 1.computed函数

   - 与Vue2.x中computed配置功能一致
   
   - 写法
   
     ```js
     import {computed} from 'vue'
     
     setup(){
         ...
     	//计算属性——简写
         let fullName = computed(()=>{
             return person.firstName + '-' + person.lastName
         })
         //计算属性——完整
         let fullName = computed({
             get(){
                 return person.firstName + '-' + person.lastName
             },
             set(value){
                 const nameArr = value.split('-')
                 person.firstName = nameArr[0]
                 person.lastName = nameArr[1]
             }
         })
     }
     ```

   ### 2.watch函数

   - 与Vue2.x中watch配置功能一致
   
   - 两个小“坑”：
   
     - 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。
     - 监视reactive定义的响应式数据中某个属性时：deep配置有效。
     
     ```js
     //情况一：监视ref定义的响应式数据
     watch(sum,(newValue,oldValue)=>{
     	console.log('sum变化了',newValue,oldValue)
     },{immediate:true})
     
     //情况二：监视多个ref定义的响应式数据
     watch([sum,msg],(newValue,oldValue)=>{
     	console.log('sum或msg变化了',newValue,oldValue)
     }) 
     
     /* 情况三：监视reactive定义的响应式数据
     			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
     			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
     */
     watch(person,(newValue,oldValue)=>{
     	console.log('person变化了',newValue,oldValue)
     },{immediate:true,deep:false}) //此处的deep配置不再奏效
     
     //情况四：监视reactive定义的响应式数据中的某个属性
     watch(()=>person.job,(newValue,oldValue)=>{
     	console.log('person的job变化了',newValue,oldValue)
     },{immediate:true,deep:true}) 
     
     //情况五：监视reactive定义的响应式数据中的某些属性
     watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{
     	console.log('person的job变化了',newValue,oldValue)
     },{immediate:true,deep:true})
     
     //特殊情况
     watch(()=>person.job,(newValue,oldValue)=>{
         console.log('person的job变化了',newValue,oldValue)
     },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
     ```

   ### 3.watchEffect函数

   - watch的套路是：既要指明监视的属性，也要指明监视的回调。
   
   - watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。
   
   - watchEffect有点像computed：
   
     - 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。
     - 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。
     
     ```js
     //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
     watchEffect(()=>{
         const x1 = sum.value
         const x2 = person.age
         console.log('watchEffect配置的回调执行了')
     })
     ```

   ## 8.生命周期

   <div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div>

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   1

   - Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
     - ```beforeDestroy```改名为 ```beforeUnmount```
     - ```destroyed```改名为 ```unmounted```
   - Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
     - `beforeCreate`===>`setup()`
     - `created`=======>`setup()`
     - `beforeMount` ===>`onBeforeMount`
     - `mounted`=======>`onMounted`
     - `beforeUpdate`===>`onBeforeUpdate`
     - `updated` =======>`onUpdated`
     - `beforeUnmount` ==>`onBeforeUnmount`
     - `unmounted` =====>`onUnmounted`

   ## 9.自定义hook函数

   - 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。
   
   - 类似于vue2.x中的mixin。
   
   - 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。

   

   ## 10.toRef

   - 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。
   - 语法：```const name = toRef(person,'name')```
   - 应用:   要将响应式对象中的某个属性单独提供给外部使用时。


   - 扩展：```toRefs``` 与```toRef```功能一致，但可以批量创建多个 ref 对象，语法：```toRefs(person)```


   # 三、其它 Composition API

   ## 1.shallowReactive 与 shallowRef

   - shallowReactive：只处理对象最外层属性的响应式（浅响应式）。
   - shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。
   
   - 什么时候使用?
     -  如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。
     -  如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef。

   ## 2.readonly 与 shallowReadonly

   - readonly: 让一个响应式数据变为只读的（深只读）。
   - shallowReadonly：让一个响应式数据变为只读的（浅只读）。
   - 应用场景: 不希望数据被修改时。

   ## 3.toRaw 与 markRaw

   - toRaw：
     - 作用：将一个由```reactive```生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。
     - 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。
   - markRaw：
     - 作用：标记一个对象，使其永远不会再成为响应式对象。
     - 应用场景:
       1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。
       2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。

   ## 4.customRef

   - 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。
   
   - 实现防抖效果：
   
     ```vue
     <template>
     	<input type="text" v-model="keyword">
     	<h3>{{keyword}}</h3>
     </template>
     
     <script>
     	import {ref,customRef} from 'vue'
     	export default {
     		name:'Demo',
     		setup(){
     			// let keyword = ref('hello') //使用Vue准备好的内置ref
     			//自定义一个myRef
     			function myRef(value,delay){
     				let timer
     				//通过customRef去实现自定义
     				return customRef((track,trigger)=>{
     					return{
     						get(){
     							track() //告诉Vue这个value值是需要被“追踪”的
     							return value
     						},
     						set(newValue){
     							clearTimeout(timer)
     							timer = setTimeout(()=>{
     								value = newValue
     								trigger() //告诉Vue去更新界面
     							},delay)
     						}
     					}
     				})
     			}
     			let keyword = myRef('hello',500) //使用程序员自定义的ref
     			return {
     				keyword
     			}
     		}
     	}
     </script>
     ```
   
     

   ## 5.provide 与 inject

   <img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

   - 作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信
   
   - 套路：父组件有一个 `provide` 选项来提供数据，后代组件有一个 `inject` 选项来开始使用这些数据
   
   - 具体写法：
   
     1. 祖组件中：
     
        ```js
        setup(){
        	......
            let car = reactive({name:'奔驰',price:'40万'})
            provide('car',car)
            ......
        }
        ```
     
     2. 后代组件中：
     
        ```js
        setup(props,context){
        	......
            const car = inject('car')
            return {car}
        	......
        }
        ```

   ## 6.响应式数据的判断

   - isRef: 检查一个值是否为一个 ref 对象
   - isReactive: 检查一个对象是否是由 `reactive` 创建的响应式代理
   - isReadonly: 检查一个对象是否是由 `readonly` 创建的只读代理
   - isProxy: 检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理

   # 四、Composition API 的优势

   ## 1.Options API 存在的问题

   使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。

   <div style="width:600px;height:370px;overflow:hidden;float:left">
       <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
   </div>
   <div style="width:300px;height:370px;overflow:hidden;float:left">
       <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
   </div>
   

   

   

   

   

   

   

   

   ## 2.Composition API 的优势

   我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。

   <div style="width:500px;height:340px;overflow:hidden;float:left">
       <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
   </div>
   <div style="width:430px;height:340px;overflow:hidden;float:left">
       <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
   </div>
   

   

   

   

   

   

   

   # 五、新的组件

   ## 1.Fragment

   - 在Vue2中: 组件必须有一个根标签
   - 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中
   - 好处: 减少标签层级, 减小内存占用

   ## 2.Teleport

   - 什么是Teleport？—— `Teleport` 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。
   
     ```vue
     <teleport to="移动位置">
     	<div v-if="isShow" class="mask">
     		<div class="dialog">
     			<h3>我是一个弹窗</h3>
     			<button @click="isShow = false">关闭弹窗</button>
     		</div>
     	</div>
     </teleport>
     ```

   ## 3.Suspense

   - 等待异步组件时渲染一些额外内容，让应用有更好的用户体验
   
   - 使用步骤：
   
     - 异步引入组件
     
       ```js
       import {defineAsyncComponent} from 'vue'
       const Child = defineAsyncComponent(()=>import('./components/Child.vue'))
       ```
     
     - 使用```Suspense```包裹组件，并配置好```default``` 与 ```fallback```
     
       ```vue
       <template>
       	<div class="app">
       		<h3>我是App组件</h3>
       		<Suspense>
       			<template v-slot:default>
       				<Child/>
       			</template>
       			<template v-slot:fallback>
       				<h3>加载中.....</h3>
       			</template>
       		</Suspense>
       	</div>
       </template>
       ```

   # 六、其他

   ## 1.全局API的转移

   - Vue 2.x 有许多全局 API 和配置。
   
     - 例如：注册全局组件、注册全局指令等。
     
       ```js
       //注册全局组件
       Vue.component('MyButton', {
         data: () => ({
           count: 0
         }),
         template: '<button @click="count++">Clicked {{ count }} times.</button>'
       })
       
       //注册全局指令
       Vue.directive('focus', {
         inserted: el => el.focus()
       }
       ```
   
   - Vue3.0中对这些API做出了调整：
   
     - 将全局的API，即：```Vue.xxx```调整到应用实例（```app```）上
     
       | 2.x 全局 API（```Vue```） | 3.x 实例 API (`app`)                        |
       | ------------------------- | ------------------------------------------- |
       | Vue.config.xxxx           | app.config.xxxx                             |
       | Vue.config.productionTip  | <strong style="color:#DD5145">移除</strong> |
       | Vue.component             | app.component                               |
       | Vue.directive             | app.directive                               |
       | Vue.mixin                 | app.mixin                                   |
       | Vue.use                   | app.use                                     |
       | Vue.prototype             | app.config.globalProperties                 |

   ## 2.其他改变

   - data选项应始终被声明为一个函数。
   
   - 过度类名的更改：
   
     - Vue2.x写法
     
       ```css
       .v-enter,
       .v-leave-to {
         opacity: 0;
       }
       .v-leave,
       .v-enter-to {
         opacity: 1;
       }
       ```
     
     - Vue3.x写法
     
       ```css
       .v-enter-from,
       .v-leave-to {
         opacity: 0;
       }
       
       .v-leave-from,
       .v-enter-to {
         opacity: 1;
       }
       ```
   
   - <strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持```config.keyCodes```
   
   - <strong style="color:#DD5145">移除</strong>```v-on.native```修饰符
   
     - 父组件中绑定事件
     
       ```vue
       <my-component
         v-on:close="handleComponentEvent"
         v-on:click="handleNativeClickEvent"
       />
       ```
     
     - 子组件中声明自定义事件
     
       ```vue
       <script>
         export default {
           emits: ['close']
         }
       </script>
       ```
   
   - <strong style="color:#DD5145">移除</strong>过滤器（filter）
   
     > 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。
   
   - ......

​    
